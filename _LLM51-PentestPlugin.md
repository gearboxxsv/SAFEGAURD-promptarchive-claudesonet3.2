I'll help you develop a comprehensive network security and penetration testing plugin for your system. Let me first analyze the requirements and the provided information to create a robust plan.

# Comprehensive Network Security Plugin Plan

## Architecture Overview

Based on your requirements, we need to build a Snort-based plugin architecture that:
1. Self-builds Docker containers
2. Performs scheduled security testing (hourly, daily, monthly)
3. Updates Snort rules periodically
4. Leverages the monitoring framework for alerts
5. Enables cores to self-heal
6. Uses the penitent collection with Zod model for type safety

Let's start by implementing the core components of this solution.

## 1. Plugin Structure Implementation

First, let's create the base plugin structure:I'll start by exploring the project structure to understand what we're working with.Let me create a comprehensive plan for the pentest plugin architecture based on your requirements.

# Network Security Pentest Plugin Implementation Plan

I'll develop a comprehensive Snort-based plugin architecture that can detect and respond to security threats in a distributed network environment. The implementation will focus on automating penetration testing, vulnerability scanning, and security monitoring.

## 1. Overall Architecture

The pentest plugin will be built with a modular architecture consisting of:

1. **Core Plugin Class** - Main entry point for initialization and scheduling
2. **Docker Container Manager** - Manages the Docker container for Snort and other security tools
3. **Rules Manager** - Handles updating and managing Snort rules
4. **Scanner Manager** - Coordinates different scanning tools (Nmap, Snort, etc.)
5. **Reporting System** - Collects and formats security findings
6. **Communication Protocol** - Enables secure communication between cores
7. **Database Interface** - Manages the penitent collection for queued actions

## 2. Implementation Components

Let's implement each component:

```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { MongoCollection } = require('meteor/mongo');
const { z } = require('zod');
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const DockerContainerManager = require('./DockerContainerManager');
const SnortRulesManager = require('./SnortRulesManager');
const ScannerManager = require('./ScannerManager');
const ReportingSystem = require('./ReportingSystem');
const PentestScheduler = require('./PentestScheduler');
const PentestCommunicator = require('./PentestCommunicator');
const PentestLogManager = require('./PentestLogManager');
const { PenitentModel } = require('./models/PenitentModel');

/**
 * PentestPlugin - Main class for the network security penetration testing plugin
 * 
 * This plugin enables automated security testing across the distributed network,
 * utilizing Snort for intrusion detection and various security tools for
 * vulnerability assessment. It can coordinate testing across multiple cores and
 * self-heal compromised systems.
 */
class PentestPlugin {
  /**
   * Constructor for PentestPlugin
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Configuration parameters
   * @param {Object} options.messageBus - Message bus for communication
   * @param {Object} options.db - Database connection
   * @param {Object} options.monitoring - Monitoring framework interface
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = this._validateConfig(options.config || {});
    this.messageBus = options.messageBus;
    this.db = options.db;
    this.monitoring = options.monitoring;
    this.pluginId = 'pentest-' + crypto.randomBytes(4).toString('hex');
    this.isRunning = false;
    this.status = 'initialized';
    
    // Initialize the penitent collection with Zod schema validation
    this.penitentCollection = new MongoCollection('penitent');
    
    // Initialize components
    this.containerManager = new DockerContainerManager({
      logger: this.logger,
      config: this.config.docker,
      pluginId: this.pluginId
    });
    
    this.rulesManager = new SnortRulesManager({
      logger: this.logger,
      config: this.config.rules,
      pluginId: this.pluginId
    });
    
    this.scannerManager = new ScannerManager({
      logger: this.logger,
      config: this.config.scanners,
      pluginId: this.pluginId
    });
    
    this.reportingSystem = new ReportingSystem({
      logger: this.logger,
      config: this.config.reporting,
      monitoring: this.monitoring,
      pluginId: this.pluginId
    });
    
    this.scheduler = new PentestScheduler({
      logger: this.logger,
      config: this.config.scheduler,
      pluginId: this.pluginId
    });
    
    this.communicator = new PentestCommunicator({
      logger: this.logger,
      config: this.config.communication,
      messageBus: this.messageBus,
      pluginId: this.pluginId
    });
    
    this.logManager = new PentestLogManager({
      logger: this.logger,
      config: this.config.logging,
      pluginId: this.pluginId
    });
    
    this.logger.info('PentestPlugin initialized successfully', { pluginId: this.pluginId });
  }
  
  /**
   * Validate and set default configuration values
   * @param {Object} config - User provided configuration
   * @returns {Object} - Validated configuration with defaults
   * @private
   */
  _validateConfig(config) {
    // Set default configuration values
    const defaultConfig = {
      docker: {
        enabled: true,
        baseImage: 'snort3/snort',
        containerName: 'pentest-snort-container',
        networkMode: 'host',
        volumes: [
          './rules:/etc/snort/rules',
          './logs:/var/log/snort'
        ]
      },
      rules: {
        updateInterval: 86400000, // 24 hours in milliseconds
        snortRulesUrl: 'https://www.snort.org/downloads/community/snort3-community-rules.tar.gz',
        customRulesDir: './custom-rules'
      },
      scanners: {
        nmap: {
          enabled: true,
          scheduledScans: {
            quickScan: {
              cronSchedule: '0 * * * *', // Hourly
              targets: 'localnet',
              options: '-sV -F --open'
            },
            fullScan: {
              cronSchedule: '0 0 * * 0', // Weekly on Sunday
              targets: 'localnet',
              options: '-sV -O -A'
            }
          }
        },
        snort: {
          enabled: true,
          configFile: '/etc/snort/snort.conf',
          interfaces: ['eth0']
        }
      },
      reporting: {
        alertThreshold: 'medium',
        reportInterval: 3600000, // 1 hour in milliseconds
        detailedReporting: true,
        dashboardIntegration: true
      },
      scheduler: {
        defaultScanInterval: 3600000, // 1 hour in milliseconds
        pentestSchedule: '0 0 * * 1', // Weekly on Monday
        pressureTestSchedule: '0 0 1 * *' // Monthly on the 1st
      },
      communication: {
        encryptionEnabled: true,
        authRequired: true,
        requestTimeout: 30000 // 30 seconds
      },
      logging: {
        level: 'info',
        retentionDays: 30,
        maxLogSize: 50 * 1024 * 1024 // 50 MB
      }
    };
    
    // Merge provided config with defaults
    const mergedConfig = {
      ...defaultConfig,
      ...config,
      docker: { ...defaultConfig.docker, ...config.docker },
      rules: { ...defaultConfig.rules, ...config.rules },
      scanners: { 
        ...defaultConfig.scanners,
        ...config.scanners,
        nmap: { ...defaultConfig.scanners.nmap, ...config?.scanners?.nmap },
        snort: { ...defaultConfig.scanners.snort, ...config?.scanners?.snort }
      },
      reporting: { ...defaultConfig.reporting, ...config.reporting },
      scheduler: { ...defaultConfig.scheduler, ...config.scheduler },
      communication: { ...defaultConfig.communication, ...config.communication },
      logging: { ...defaultConfig.logging, ...config.logging }
    };
    
    return mergedConfig;
  }
  
  /**
   * Initialize the plugin
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing PentestPlugin', { pluginId: this.pluginId });
      this.status = 'initializing';
      
      // Setup database with proper indexes
      await this._setupDatabase();
      
      // Initialize the Docker container
      if (this.config.docker.enabled) {
        await this.containerManager.init();
      }
      
      // Initialize the rules manager and update rules
      await this.rulesManager.init();
      
      // Initialize scanner manager
      await this.scannerManager.init();
      
      // Initialize reporting system
      await this.reportingSystem.init();
      
      // Initialize scheduler and set up scheduled tasks
      await this.scheduler.init();
      this.scheduler.on('scheduled-scan', this._handleScheduledScan.bind(this));
      this.scheduler.on('scheduled-pentest', this._handleScheduledPentest.bind(this));
      
      // Initialize communicator
      await this.communicator.init();
      this.communicator.on('pentest-request', this._handlePentestRequest.bind(this));
      this.communicator.on('vulnerability-report', this._handleVulnerabilityReport.bind(this));
      
      // Initialize log manager
      await this.logManager.init();
      
      // Register with monitoring framework
      this._registerWithMonitoring();
      
      this.isRunning = true;
      this.status = 'running';
      this.logger.info('PentestPlugin initialized successfully', { pluginId: this.pluginId });
      
      return true;
    } catch (error) {
      this.status = 'error';
      this.logger.error('Failed to initialize PentestPlugin', { error: error.message, stack: error.stack });
      throw error;
    }
  }
  
  /**
   * Set up database collections and indexes
   * @private
   */
  async _setupDatabase() {
    // Create indexes for penitent collection
    await this.penitentCollection.createIndex({ targetId: 1 });
    await this.penitentCollection.createIndex({ status: 1 });
    await this.penitentCollection.createIndex({ scheduledTime: 1 });
    await this.penitentCollection.createIndex({ priority: 1 });
    
    this.logger.info('Database setup completed');
  }
  
  /**
   * Register the plugin with the monitoring framework
   * @private
   */
  _registerWithMonitoring() {
    if (this.monitoring) {
      this.monitoring.registerMetric({
        name: 'pentest_plugin_status',
        type: 'gauge',
        description: 'Current status of the pentest plugin',
        labels: ['status', 'plugin_id']
      });
      
      this.monitoring.registerMetric({
        name: 'pentest_scans_total',
        type: 'counter',
        description: 'Total number of security scans performed',
        labels: ['scan_type', 'result']
      });
      
      this.monitoring.registerMetric({
        name: 'pentest_vulnerabilities_detected',
        type: 'counter',
        description: 'Number of vulnerabilities detected',
        labels: ['severity', 'type']
      });
      
      this.monitoring.registerMetric({
        name: 'pentest_rule_updates',
        type: 'counter',
        description: 'Number of rule updates performed',
        labels: ['result']
      });
      
      this.monitoring.registerAlert({
        name: 'high_severity_vulnerability',
        description: 'A high severity vulnerability was detected',
        threshold: 1,
        interval: '5m',
        actions: ['notify', 'escalate']
      });
      
      this.logger.info('Registered metrics and alerts with monitoring framework');
    }
  }
  
  /**
   * Handle scheduled scan events from the scheduler
   * @param {Object} scanConfig - Configuration for the scan
   * @private
   */
  async _handleScheduledScan(scanConfig) {
    try {
      this.logger.info('Handling scheduled scan', { scanConfig });
      
      // Queue a new scan task in the penitent collection
      const scanTask = new PenitentModel({
        taskType: 'scan',
        targetId: scanConfig.target || 'local',
        scanType: scanConfig.scanType,
        scanOptions: scanConfig.options,
        priority: scanConfig.priority || 'normal',
        status: 'pending',
        createdAt: new Date(),
        scheduledTime: new Date()
      });
      
      await this.penitentCollection.insertOne(scanTask);
      
      // Process the queued task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error handling scheduled scan', { error: error.message });
      
      // Report error to monitoring
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: scanConfig.scanType, 
          result: 'error' 
        });
        
        this.monitoring.reportAlert('scan_failure', {
          message: `Scheduled scan failed: ${error.message}`,
          scanConfig
        });
      }
    }
  }
  
  /**
   * Handle scheduled pentest events from the scheduler
   * @param {Object} pentestConfig - Configuration for the pentest
   * @private
   */
  async _handleScheduledPentest(pentestConfig) {
    try {
      this.logger.info('Handling scheduled penetration test', { pentestConfig });
      
      // For comprehensive pentests, we coordinate with other cores
      if (pentestConfig.scope === 'distributed') {
        // Request other cores to perform self-assessment
        await this.communicator.requestDistributedPentest(pentestConfig);
      }
      
      // Queue local pentest task
      const pentestTask = new PenitentModel({
        taskType: 'pentest',
        targetId: 'local',
        testType: pentestConfig.testType,
        testOptions: pentestConfig.options,
        priority: 'high',
        status: 'pending',
        createdAt: new Date(),
        scheduledTime: new Date()
      });
      
      await this.penitentCollection.insertOne(pentestTask);
      
      // Process the queued task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error handling scheduled pentest', { error: error.message });
      
      // Report error to monitoring
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: 'comprehensive_pentest', 
          result: 'error' 
        });
        
        this.monitoring.reportAlert('pentest_failure', {
          message: `Scheduled penetration test failed: ${error.message}`,
          pentestConfig
        });
      }
    }
  }
  
  /**
   * Handle a pentest request from another core
   * @param {Object} request - Pentest request details
   * @private
   */
  async _handlePentestRequest(request) {
    try {
      this.logger.info('Received pentest request from another core', { 
        sourceId: request.sourceId,
        requestId: request.requestId 
      });
      
      // Validate the request
      if (!this.communicator.validateRequest(request)) {
        throw new Error('Invalid pentest request');
      }
      
      // Queue the requested pentest task
      const pentestTask = new PenitentModel({
        taskType: 'pentest',
        requestId: request.requestId,
        sourceId: request.sourceId,
        targetId: 'local',
        testType: request.testType,
        testOptions: request.options,
        priority: request.priority || 'high',
        status: 'pending',
        createdAt: new Date(),
        scheduledTime: new Date()
      });
      
      await this.penitentCollection.insertOne(pentestTask);
      
      // Acknowledge receipt of the request
      await this.communicator.acknowledgePentestRequest(request);
      
      // Process the queued task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error handling pentest request', { 
        error: error.message,
        request 
      });
      
      // Report rejection to the requesting core
      if (request && request.sourceId && request.requestId) {
        await this.communicator.rejectPentestRequest(request, error.message);
      }
    }
  }
  
  /**
   * Handle vulnerability reports from other cores
   * @param {Object} report - Vulnerability report
   * @private
   */
  async _handleVulnerabilityReport(report) {
    try {
      this.logger.info('Received vulnerability report from another core', {
        sourceId: report.sourceId,
        vulnerabilities: report.vulnerabilities.length
      });
      
      // Validate the report
      if (!this.communicator.validateReport(report)) {
        throw new Error('Invalid vulnerability report');
      }
      
      // Process and store the report
      await this.reportingSystem.processExternalReport(report);
      
      // If critical vulnerabilities exist, queue self-healing tasks
      const criticalVulnerabilities = report.vulnerabilities.filter(v => 
        v.severity === 'critical' || v.severity === 'high'
      );
      
      if (criticalVulnerabilities.length > 0) {
        await this._queueSelfHealingTasks(criticalVulnerabilities);
      }
      
      // Acknowledge receipt of the report
      await this.communicator.acknowledgeVulnerabilityReport(report);
      
    } catch (error) {
      this.logger.error('Error handling vulnerability report', {
        error: error.message,
        report
      });
    }
  }
  
  /**
   * Process the next pending task from the penitent collection
   * @private
   */
  async _processNextPendingTask() {
    try {
      // Find the highest priority pending task
      const nextTask = await this.penitentCollection.findOne(
        { status: 'pending' },
        { sort: { priority: -1, scheduledTime: 1 } }
      );
      
      if (!nextTask) {
        this.logger.debug('No pending tasks to process');
        return;
      }
      
      // Update task status to processing
      await this.penitentCollection.updateOne(
        { _id: nextTask._id },
        { $set: { status: 'processing', startedAt: new Date() } }
      );
      
      // Process based on task type
      if (nextTask.taskType === 'scan') {
        await this._executeScanTask(nextTask);
      } else if (nextTask.taskType === 'pentest') {
        await this._executePentestTask(nextTask);
      } else if (nextTask.taskType === 'self-heal') {
        await this._executeSelfHealTask(nextTask);
      } else {
        throw new Error(`Unknown task type: ${nextTask.taskType}`);
      }
      
    } catch (error) {
      this.logger.error('Error processing next pending task', { error: error.message });
    }
  }
  
  /**
   * Execute a scan task
   * @param {Object} task - Scan task details
   * @private
   */
  async _executeScanTask(task) {
    try {
      this.logger.info('Executing scan task', { taskId: task._id, scanType: task.scanType });
      
      let results;
      if (task.scanType === 'nmap') {
        results = await this.scannerManager.runNmapScan(task.scanOptions, task.targetId);
      } else if (task.scanType === 'snort') {
        results = await this.scannerManager.runSnortDetection(task.scanOptions);
      } else {
        throw new Error(`Unsupported scan type: ${task.scanType}`);
      }
      
      // Process scan results
      const vulnerabilities = await this.reportingSystem.processScanResults(results, task.scanType);
      
      // Update task status to completed
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: 'completed', 
            completedAt: new Date(),
            results: {
              summary: vulnerabilities.summary,
              vulnerabilitiesCount: vulnerabilities.items.length
            }
          } 
        }
      );
      
      // Report metrics
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: task.scanType, 
          result: 'success' 
        });
        
        // Report vulnerability metrics
        vulnerabilities.items.forEach(vuln => {
          this.monitoring.reportMetric('pentest_vulnerabilities_detected', 1, {
            severity: vuln.severity,
            type: vuln.type
          });
        });
      }
      
      // Process the next task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error executing scan task', { 
        error: error.message,
        taskId: task._id 
      });
      
      // Update task status to failed
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: 'failed', 
            completedAt: new Date(),
            error: error.message
          } 
        }
      );
      
      // Report metrics
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: task.scanType, 
          result: 'error' 
        });
      }
      
      // Process the next task
      await this._processNextPendingTask();
    }
  }
  
  /**
   * Execute a pentest task
   * @param {Object} task - Pentest task details
   * @private
   */
  async _executePentestTask(task) {
    try {
      this.logger.info('Executing penetration test task', { 
        taskId: task._id, 
        testType: task.testType 
      });
      
      // Run comprehensive penetration test using multiple tools
      const results = await this.scannerManager.runComprehensivePentest(
        task.testType,
        task.testOptions,
        task.targetId
      );
      
      // Process results and generate detailed report
      const vulnerabilities = await this.reportingSystem.processPentestResults(results, task.testType);
      
      // Update task status to completed
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: 'completed', 
            completedAt: new Date(),
            results: {
              summary: vulnerabilities.summary,
              vulnerabilitiesCount: vulnerabilities.items.length,
              criticalCount: vulnerabilities.items.filter(v => v.severity === 'critical').length,
              highCount: vulnerabilities.items.filter(v => v.severity === 'high').length
            }
          } 
        }
      );
      
      // If this was a requested pentest, send results back to requestor
      if (task.sourceId && task.requestId) {
        await this.communicator.sendVulnerabilityReport({
          requestId: task.requestId,
          sourceId: task.sourceId,
          vulnerabilities: vulnerabilities.items,
          summary: vulnerabilities.summary,
          timestamp: new Date()
        });
      }
      
      // Report metrics
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: 'comprehensive_pentest', 
          result: 'success' 
        });
        
        // Report vulnerability metrics
        vulnerabilities.items.forEach(vuln => {
          this.monitoring.reportMetric('pentest_vulnerabilities_detected', 1, {
            severity: vuln.severity,
            type: vuln.type
          });
        });
      }
      
      // Queue self-healing tasks for critical vulnerabilities
      const criticalVulnerabilities = vulnerabilities.items.filter(v => 
        v.severity === 'critical' || v.severity === 'high'
      );
      
      if (criticalVulnerabilities.length > 0) {
        await this._queueSelfHealingTasks(criticalVulnerabilities);
      }
      
      // Process the next task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error executing pentest task', { 
        error: error.message,
        taskId: task._id 
      });
      
      // Update task status to failed
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: 'failed', 
            completedAt: new Date(),
            error: error.message
          } 
        }
      );
      
      // If this was a requested pentest, notify requestor of failure
      if (task.sourceId && task.requestId) {
        await this.communicator.sendPentestFailure({
          requestId: task.requestId,
          sourceId: task.sourceId,
          error: error.message,
          timestamp: new Date()
        });
      }
      
      // Report metrics
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_scans_total', 1, { 
          scan_type: 'comprehensive_pentest', 
          result: 'error' 
        });
      }
      
      // Process the next task
      await this._processNextPendingTask();
    }
  }
  
  /**
   * Execute a self-healing task
   * @param {Object} task - Self-healing task details
   * @private
   */
  async _executeSelfHealTask(task) {
    try {
      this.logger.info('Executing self-healing task', { 
        taskId: task._id, 
        vulnerabilityId: task.vulnerabilityId
      });
      
      // Get vulnerability details
      const vulnerability = task.vulnerabilityDetails;
      
      if (!vulnerability) {
        throw new Error('Vulnerability details not found in task');
      }
      
      // Attempt to apply remediation
      const remediationResult = await this.scannerManager.applySelfHealing(
        vulnerability,
        task.remediationStrategy
      );
      
      // Update task status
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: remediationResult.success ? 'completed' : 'failed', 
            completedAt: new Date(),
            results: remediationResult
          } 
        }
      );
      
      // Log the result
      if (remediationResult.success) {
        this.logger.info('Self-healing task completed successfully', {
          taskId: task._id,
          vulnerabilityId: task.vulnerabilityId
        });
        
        // Report to monitoring
        if (this.monitoring) {
          this.monitoring.reportMetric('pentest_self_healing', 1, { 
            result: 'success',
            vulnerability_type: vulnerability.type
          });
        }
      } else {
        this.logger.warn('Self-healing task failed', {
          taskId: task._id,
          vulnerabilityId: task.vulnerabilityId,
          error: remediationResult.error
        });
        
        // Report to monitoring
        if (this.monitoring) {
          this.monitoring.reportMetric('pentest_self_healing', 1, { 
            result: 'failure',
            vulnerability_type: vulnerability.type
          });
          
          this.monitoring.reportAlert('self_healing_failure', {
            message: `Failed to self-heal vulnerability: ${remediationResult.error}`,
            vulnerability: vulnerability
          });
        }
      }
      
      // Process the next task
      await this._processNextPendingTask();
      
    } catch (error) {
      this.logger.error('Error executing self-healing task', { 
        error: error.message,
        taskId: task._id 
      });
      
      // Update task status to failed
      await this.penitentCollection.updateOne(
        { _id: task._id },
        { 
          $set: { 
            status: 'failed', 
            completedAt: new Date(),
            error: error.message
          } 
        }
      );
      
      // Report to monitoring
      if (this.monitoring) {
        this.monitoring.reportMetric('pentest_self_healing', 1, { 
          result: 'error'
        });
      }
      
      // Process the next task
      await this._processNextPendingTask();
    }
  }
  
  /**
   * Queue self-healing tasks for critical vulnerabilities
   * @param {Array} vulnerabilities - List of critical vulnerabilities
   * @private
   */
  async _queueSelfHealingTasks(vulnerabilities) {
    for (const vulnerability of vulnerabilities) {
      // Check if vulnerability has a remediation strategy
      if (!vulnerability.remediationStrategy) {
        this.logger.warn('No remediation strategy available for vulnerability', {
          vulnerabilityId: vulnerability.id,
          type: vulnerability.type
        });
        continue;
      }
      
      // Create a self-healing task
      const selfHealTask = new PenitentModel({
        taskType: 'self-heal',
        vulnerabilityId: vulnerability.id,
        vulnerabilityDetails: vulnerability,
        remediationStrategy: vulnerability.remediationStrategy,
        priority: vulnerability.severity === 'critical' ? 'critical' : 'high',
        status: 'pending',
        createdAt: new Date(),
        scheduledTime: new Date()
      });
      
      await this.penitentCollection.insertOne(selfHealTask);
      
      this.logger.info('Queued self-healing task', {
        taskId: selfHealTask._id,
        vulnerabilityId: vulnerability.id,
        severity: vulnerability.severity
      });
    }
  }
  
  /**
   * Start the plugin's operation
   * @returns {Promise<boolean>} - True if start was successful
   */
  async start() {
    if (this.isRunning) {
      this.logger.info('PentestPlugin is already running');
      return true;
    }
    
    try {
      this.logger.info('Starting PentestPlugin');
      this.status = 'starting';
      
      // Start the Docker container if enabled
      if (this.config.docker.enabled) {
        await this.containerManager.start();
      }
      
      // Start Snort detection
      if (this.config.scanners.snort.enabled) {
        await this.scannerManager.startSnort();
      }
      
      // Start scheduled tasks
      await this.scheduler.start();
      
      // Process any pending tasks from previous runs
      await this._processNextPendingTask();
      
      this.isRunning = true;
      this.status = 'running';
      this.logger.info('PentestPlugin started successfully');
      
      return true;
    } catch (error) {
      this.status = 'error';
      this.logger.error('Failed to start PentestPlugin', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Stop the plugin's operation
   * @returns {Promise<boolean>} - True if stop was successful
   */
  async stop() {
    if (!this.isRunning) {
      this.logger.info('PentestPlugin is not running');
      return true;
    }
    
    try {
      this.logger.info('Stopping PentestPlugin');
      this.status = 'stopping';
      
      // Stop scheduled tasks
      await this.scheduler.stop();
      
      // Stop Snort detection
      if (this.config.scanners.snort.enabled) {
        await this.scannerManager.stopSnort();
      }
      
      // Stop the Docker container if enabled
      if (this.config.docker.enabled) {
        await this.containerManager.stop();
      }
      
      this.isRunning = false;
      this.status = 'stopped';
      this.logger.info('PentestPlugin stopped successfully');
      
      return true;
    } catch (error) {
      this.status = 'error';
      this.logger.error('Failed to stop PentestPlugin', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Restart the plugin
   * @returns {Promise<boolean>} - True if restart was successful
   */
  async restart() {
    try {
      this.logger.info('Restarting PentestPlugin');
      await this.stop();
      await this.start();
      return true;
    } catch (error) {
      this.logger.error('Failed to restart PentestPlugin', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Get the current status of the plugin
   * @returns {Object} - Status information
   */
  getStatus() {
    return {
      pluginId: this.pluginId,
      status: this.status,
      isRunning: this.isRunning,
      containerStatus: this.containerManager.getStatus(),
      snortStatus: this.scannerManager.getSnortStatus(),
      lastRulesUpdate: this.rulesManager.getLastUpdateTime(),
      scheduledTasks: this.scheduler.getScheduledTasks(),
      pendingTasksCount: this.penitentCollection.find({ status: 'pending' }).count(),
      processingTasksCount: this.penitentCollection.find({ status: 'processing' }).count()
    };
  }
}

module.exports = PentestPlugin;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

/**
 * DockerContainerManager - Manages Docker containers for security tools
 * 
 * This class handles the lifecycle of Docker containers used by the pentest plugin,
 * including creation, starting, stopping, and cleanup operations.
 */
class DockerContainerManager {
  /**
   * Constructor for DockerContainerManager
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Docker configuration
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = options.config || {};
    this.pluginId = options.pluginId;
    this.containerName = this.config.containerName || `pentest-snort-${crypto.randomBytes(4).toString('hex')}`;
    this.baseImage = this.config.baseImage || 'snort3/snort';
    this.isRunning = false;
    this.containerStatus = 'stopped';
    this.containerId = null;
    this.mountDirectories = {
      rules: path.resolve(process.cwd(), 'private/plugins/modules/pentest/rules'),
      logs: path.resolve(process.cwd(), 'private/plugins/modules/pentest/logs'),
      configs: path.resolve(process.cwd(), 'private/plugins/modules/pentest/configs')
    };
  }
  
  /**
   * Initialize the Docker container manager
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing Docker container manager');
      
      // Check if Docker is installed and running
      await this._checkDockerAvailability();
      
      // Create necessary directories for volume mounts
      await this._createMountDirectories();
      
      // Pull the base image if needed
      await this._pullImage();
      
      // Check if container already exists
      const containerExists = await this._checkContainerExists();
      
      if (containerExists) {
        // Get container ID
        this.containerId = await this._getContainerId();
        this.logger.info('Container already exists', { 
          containerId: this.containerId,
          containerName: this.containerName
        });
      } else {
        // Create the container but don't start it yet
        await this._createContainer();
      }
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize Docker container manager', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Check if Docker is installed and running
   * @private
   */
  async _checkDockerAvailability() {
    try {
      const { stdout } = await exec('docker version --format "{{.Server.Version}}"');
      this.logger.info(`Docker is available, version: ${stdout.trim()}`);
    } catch (error) {
      throw new Error(`Docker is not available: ${error.message}`);
    }
  }
  
  /**
   * Create necessary directories for volume mounts
   * @private
   */
  async _createMountDirectories() {
    try {
      // Create rules directory if it doesn't exist
      if (!fs.existsSync(this.mountDirectories.rules)) {
        fs.mkdirSync(this.mountDirectories.rules, { recursive: true });
        this.logger.info(`Created rules directory: ${this.mountDirectories.rules}`);
      }
      
      // Create logs directory if it doesn't exist
      if (!fs.existsSync(this.mountDirectories.logs)) {
        fs.mkdirSync(this.mountDirectories.logs, { recursive: true });
        this.logger.info(`Created logs directory: ${this.mountDirectories.logs}`);
      }
      
      // Create configs directory if it doesn't exist
      if (!fs.existsSync(this.mountDirectories.configs)) {
        fs.mkdirSync(this.mountDirectories.configs, { recursive: true });
        this.logger.info(`Created configs directory: ${this.mountDirectories.configs}`);
      }
    } catch (error) {
      throw new Error(`Failed to create mount directories: ${error.message}`);
    }
  }
  
  /**
   * Pull the Docker image
   * @private
   */
  async _pullImage() {
    try {
      // Check if image already exists
      const { stdout: images } = await exec(`docker images -q ${this.baseImage}`);
      
      if (images.trim() !== '') {
        this.logger.info(`Image ${this.baseImage} already exists`);
        return;
      }
      
      this.logger.info(`Pulling Docker image: ${this.baseImage}`);
      const { stdout, stderr } = await exec(`docker pull ${this.baseImage}`);
      this.logger.debug('Docker pull output', { stdout, stderr });
      this.logger.info(`Successfully pulled Docker image: ${this.baseImage}`);
    } catch (error) {
      throw new Error(`Failed to pull Docker image: ${error.message}`);
    }
  }
  
  /**
   * Check if container already exists
   * @returns {Promise<boolean>} - True if container exists
   * @private
   */
  async _checkContainerExists() {
    try {
      const { stdout } = await exec(`docker ps -a -f "name=${this.containerName}" --format "{{.Names}}"`);
      return stdout.trim() === this.containerName;
    } catch (error) {
      this.logger.error('Error checking if container exists', { error: error.message });
      return false;
    }
  }
  
  /**
   * Get container ID
   * @returns {Promise<string>} - Container ID
   * @private
   */
  async _getContainerId() {
    try {
      const { stdout } = await exec(`docker ps -a -f "name=${this.containerName}" --format "{{.ID}}"`);
      return stdout.trim();
    } catch (error) {
      throw new Error(`Failed to get container ID: ${error.message}`);
    }
  }
  
  /**
   * Create the Docker container
   * @private
   */
  async _createContainer() {
    try {
      this.logger.info(`Creating Docker container: ${this.containerName}`);
      
      // Prepare volume mounts
      const volumeMounts = [
        `-v ${this.mountDirectories.rules}:/etc/snort/rules`,
        `-v ${this.mountDirectories.logs}:/var/log/snort`,
        `-v ${this.mountDirectories.configs}:/etc/snort`
      ];
      
      // Prepare network mode
      const networkMode = this.config.networkMode ? `--network=${this.config.networkMode}` : '';
      
      // Additional options
      const additionalOptions = this.config.additionalOptions || '';
      
      // Prepare full docker create command
      const createCmd = `docker create --name ${this.containerName} ${networkMode} ${volumeMounts.join(' ')} ${additionalOptions} ${this.baseImage}`;
      
      this.logger.debug('Docker create command', { command: createCmd });
      
      const { stdout, stderr } = await exec(createCmd);
      this.containerId = stdout.trim();
      
      this.logger.info(`Successfully created Docker container`, { 
        containerId: this.containerId,
        containerName: this.containerName
      });
      
      return this.containerId;
    } catch (error) {
      throw new Error(`Failed to create Docker container: ${error.message}`);
    }
  }
  
  /**
   * Start the Docker container
   * @returns {Promise<boolean>} - True if start was successful
   */
  async start() {
    try {
      if (this.isRunning) {
        this.logger.info('Container is already running');
        return true;
      }
      
      this.logger.info(`Starting Docker container: ${this.containerName}`);
      
      // Check if container exists
      const containerExists = await this._checkContainerExists();
      
      if (!containerExists) {
        // Create the container if it doesn't exist
        await this._createContainer();
      } else {
        // Get container ID if we don't have it yet
        if (!this.containerId) {
          this.containerId = await this._getContainerId();
        }
      }
      
      // Start the container
      const { stdout, stderr } = await exec(`docker start ${this.containerName}`);
      this.logger.debug('Docker start output', { stdout, stderr });
      
      // Update status
      this.isRunning = true;
      this.containerStatus = 'running';
      
      this.logger.info(`Successfully started Docker container`, { 
        containerId: this.containerId,
        containerName: this.containerName
      });
      
      return true;
    } catch (error) {
      this.logger.error('Failed to start Docker container', { error: error.message });
      this.containerStatus = 'error';
      throw error;
    }
  }
  
  /**
   * Stop the Docker container
   * @returns {Promise<boolean>} - True if stop was successful
   */
  async stop() {
    try {
      if (!this.isRunning) {
        this.logger.info('Container is not running');
        return true;
      }
      
      this.logger.info(`Stopping Docker container: ${this.containerName}`);
      
      // Stop the container
      const { stdout, stderr } = await exec(`docker stop ${this.containerName}`);
      this.logger.debug('Docker stop output', { stdout, stderr });
      
      // Update status
      this.isRunning = false;
      this.containerStatus = 'stopped';
      
      this.logger.info(`Successfully stopped Docker container`, { 
        containerId: this.containerId,
        containerName: this.containerName
      });
      
      return true;
    } catch (error) {
      this.logger.error('Failed to stop Docker container', { error: error.message });
      this.containerStatus = 'error';
      throw error;
    }
  }
  
  /**
   * Execute a command inside the Docker container
   * @param {string} command - Command to execute
   * @returns {Promise<Object>} - Command execution result
   */
  async execCommand(command) {
    try {
      if (!this.isRunning) {
        throw new Error('Container is not running');
      }
      
      this.logger.debug(`Executing command in container: ${command}`);
      
      const { stdout, stderr } = await exec(`docker exec ${this.containerName} ${command}`);
      
      return {
        success: true,
        stdout,
        stderr
      };
    } catch (error) {
      this.logger.error('Failed to execute command in container', { 
        error: error.message,
        command 
      });
      
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Get container status
   * @returns {Object} - Container status information
   */
  getStatus() {
    return {
      containerId: this.containerId,
      containerName: this.containerName,
      status: this.containerStatus,
      isRunning: this.isRunning,
      image: this.baseImage
    };
  }
  
  /**
   * Clean up the Docker container
   * @returns {Promise<boolean>} - True if cleanup was successful
   */
  async cleanup() {
    try {
      // First stop the container if it's running
      if (this.isRunning) {
        await this.stop();
      }
      
      this.logger.info(`Removing Docker container: ${this.containerName}`);
      
      // Remove the container
      const { stdout, stderr } = await exec(`docker rm ${this.containerName}`);
      this.logger.debug('Docker remove output', { stdout, stderr });
      
      // Update status
      this.containerId = null;
      this.containerStatus = 'removed';
      
      this.logger.info(`Successfully removed Docker container`);
      
      return true;
    } catch (error) {
      this.logger.error('Failed to clean up Docker container', { error: error.message });
      throw error;
    }
  }
}

module.exports = DockerContainerManager;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const crypto = require('crypto');
const zlib = require('zlib');
const tar = require('tar');
const stream = require('stream');
const pipeline = promisify(stream.pipeline);

/**
 * SnortRulesManager - Manages Snort rules and updates
 * 
 * This class handles downloading, updating, and managing Snort rules,
 * ensuring that the IDS has up-to-date detection capabilities.
 */
class SnortRulesManager {
  /**
   * Constructor for SnortRulesManager
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Rules configuration
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = options.config || {};
    this.pluginId = options.pluginId;
    this.rulesDirectory = path.resolve(process.cwd(), 'private/plugins/modules/pentest/rules');
    this.customRulesDirectory = path.resolve(process.cwd(), 'private/plugins/modules/pentest/rules/custom');
    this.backupDirectory = path.resolve(process.cwd(), 'private/plugins/modules/pentest/rules/backup');
    this.tempDirectory = path.resolve(process.cwd(), 'private/plugins/modules/pentest/rules/temp');
    this.snortRulesUrl = this.config.snortRulesUrl || 'https://www.snort.org/downloads/community/snort3-community-rules.tar.gz';
    this.updateInterval = this.config.updateInterval || 86400000; // 24 hours in milliseconds
    this.lastUpdateTime = null;
    this.updateTimer = null;
    this.isUpdating = false;
  }
  
  /**
   * Initialize the rules manager
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing SnortRulesManager');
      
      // Create necessary directories
      await this._createDirectories();
      
      // Check if rules exist and download if needed
      const rulesExist = await this._checkRulesExist();
      
      if (!rulesExist) {
        // Download rules for the first time
        await this.updateRules();
      } else {
        // Get the last update time
        await this._getLastUpdateTime();
        
        // Check if rules need to be updated
        const timeSinceLastUpdate = this.lastUpdateTime ? Date.now() - this.lastUpdateTime.getTime() : Infinity;
        
        if (timeSinceLastUpdate >= this.updateInterval) {
          this.logger.info('Rules are outdated, updating...');
          await this.updateRules();
        } else {
          this.logger.info('Rules are up to date', {
            lastUpdate: this.lastUpdateTime,
            nextUpdateIn: Math.floor((this.updateInterval - timeSinceLastUpdate) / 1000 / 60) + ' minutes'
          });
        }
      }
      
      // Schedule automatic updates
      this._scheduleNextUpdate();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize SnortRulesManager', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Create necessary directories for rules
   * @private
   */
  async _createDirectories() {
    try {
      // Create main rules directory if it doesn't exist
      if (!fs.existsSync(this.rulesDirectory)) {
        fs.mkdirSync(this.rulesDirectory, { recursive: true });
        this.logger.info(`Created rules directory: ${this.rulesDirectory}`);
      }
      
      // Create custom rules directory if it doesn't exist
      if (!fs.existsSync(this.customRulesDirectory)) {
        fs.mkdirSync(this.customRulesDirectory, { recursive: true });
        this.logger.info(`Created custom rules directory: ${this.customRulesDirectory}`);
      }
      
      // Create backup directory if it doesn't exist
      if (!fs.existsSync(this.backupDirectory)) {
        fs.mkdirSync(this.backupDirectory, { recursive: true });
        this.logger.info(`Created backup directory: ${this.backupDirectory}`);
      }
      
      // Create temp directory if it doesn't exist
      if (!fs.existsSync(this.tempDirectory)) {
        fs.mkdirSync(this.tempDirectory, { recursive: true });
        this.logger.info(`Created temp directory: ${this.tempDirectory}`);
      }
    } catch (error) {
      throw new Error(`Failed to create rules directories: ${error.message}`);
    }
  }
  
  /**
   * Check if rules files exist
   * @returns {Promise<boolean>} - True if rules exist
   * @private
   */
  async _checkRulesExist() {
    try {
      // Look for .rules files in the rules directory
      const files = fs.readdirSync(this.rulesDirectory);
      const ruleFiles = files.filter(file => file.endsWith('.rules'));
      
      return ruleFiles.length > 0;
    } catch (error) {
      this.logger.error('Error checking if rules exist', { error: error.message });
      return false;
    }
  }
  
  /**
   * Get the last update time for rules
   * @private
   */
  async _getLastUpdateTime() {
    try {
      const metadataPath = path.join(this.rulesDirectory, 'metadata.json');
      
      if (fs.existsSync(metadataPath)) {
        const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
        this.lastUpdateTime = new Date(metadata.lastUpdateTime);
        this.logger.info('Found rules metadata', { lastUpdateTime: this.lastUpdateTime });
      } else {
        this.logger.info('No rules metadata found, will create on next update');
        this.lastUpdateTime = null;
      }
    } catch (error) {
      this.logger.error('Error getting last update time', { error: error.message });
      this.lastUpdateTime = null;
    }
  }
  
  /**
   * Update Snort rules
   * @returns {Promise<boolean>} - True if update was successful
   */
  async updateRules() {
    if (this.isUpdating) {
      this.logger.info('Rules update already in progress');
      return false;
    }
    
    this.isUpdating = true;
    
    try {
      this.logger.info('Starting Snort rules update');
      
      // Create a timestamped backup of current rules
      await this._backupCurrentRules();
      
      // Download and extract new rules
      await this._downloadRules();
      
      // Update metadata
      await this._updateMetadata();
      
      // Reset update timer
      this._scheduleNextUpdate();
      
      this.isUpdating = false;
      this.logger.info('Snort rules update completed successfully');
      
      return true;
    } catch (error) {
      this.isUpdating = false;
      this.logger.error('Failed to update Snort rules', { error: error.message });
      
      // Try to restore from backup if update failed
      try {
        await this._restoreFromBackup();
      } catch (restoreError) {
        this.logger.error('Failed to restore rules from backup', { error: restoreError.message });
      }
      
      throw error;
    }
  }
  
  /**
   * Backup current rules
   * @private
   */
  async _backupCurrentRules() {
    try {
      const ruleFiles = fs.readdirSync(this.rulesDirectory)
        .filter(file => file.endsWith('.rules') || file === 'metadata.json');
      
      if (ruleFiles.length === 0) {
        this.logger.info('No rules to backup');
        return;
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupDir = path.join(this.backupDirectory, `backup-${timestamp}`);
      
      // Create backup directory
      fs.mkdirSync(backupDir, { recursive: true });
      
      // Copy rule files to backup directory
      for (const file of ruleFiles) {
        const sourcePath = path.join(this.rulesDirectory, file);
        const destPath = path.join(backupDir, file);
        fs.copyFileSync(sourcePath, destPath);
      }
      
      this.logger.info('Backed up current rules', { backupDir });
    } catch (error) {
      throw new Error(`Failed to backup current rules: ${error.message}`);
    }
  }
  
  /**
   * Download and extract Snort rules
   * @private
   */
  async _downloadRules() {
    try {
      this.logger.info(`Downloading Snort rules from: ${this.snortRulesUrl}`);
      
      // Clear temp directory
      if (fs.existsSync(this.tempDirectory)) {
        const tempFiles = fs.readdirSync(this.tempDirectory);
        for (const file of tempFiles) {
          fs.unlinkSync(path.join(this.tempDirectory, file));
        }
      }
      
      // Create a temporary file for the downloaded rules
      const tempFilePath = path.join(this.tempDirectory, 'snort-rules.tar.gz');
      
      // Download the rules file
      const response = await axios({
        method: 'get',
        url: this.snortRulesUrl,
        responseType: 'stream'
      });
      
      // Save the downloaded file
      const writer = fs.createWriteStream(tempFilePath);
      await pipeline(response.data, writer);
      
      this.logger.info('Downloaded rules file successfully');
      
      // Extract the rules
      await this._extractRules(tempFilePath);
      
      // Cleanup temp file
      fs.unlinkSync(tempFilePath);
      
      this.logger.info('Rules extraction completed');
    } catch (error) {
      throw new Error(`Failed to download Snort rules: ${error.message}`);
    }
  }
  
  /**
   * Extract downloaded rules
   * @param {string} filePath - Path to the downloaded rules file
   * @private
   */
  async _extractRules(filePath) {
    try {
      this.logger.info(`Extracting rules from: ${filePath}`);
      
      // Extract to the temp directory first
      await tar.extract({
        file: filePath,
        cwd: this.tempDirectory
      });
      
      // Get a list of all .rules files in the extracted content
      const findRulesFiles = (dir) => {
        let results = [];
        const files = fs.readdirSync(dir);
        
        for (const file of files) {
          const fullPath = path.join(dir, file);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            results = results.concat(findRulesFiles(fullPath));
          } else if (file.endsWith('.rules')) {
            results.push(fullPath);
          }
        }
        
        return results;
      };
      
      const extractedRulesFiles = findRulesFiles(this.tempDirectory);
      
      // Move the rules files to the rules directory
      for (const file of extractedRulesFiles) {
        const filename = path.basename(file);
        const destPath = path.join(this.rulesDirectory, filename);
        
        fs.copyFileSync(file, destPath);
        this.logger.debug(`Moved rule file: ${filename}`);
      }
      
      this.logger.info(`Extracted ${extractedRulesFiles.length} rule files`);
    } catch (error) {
      throw new Error(`Failed to extract Snort rules: ${error.message}`);
    }
  }
  
  /**
   * Update rules metadata
   * @private
   */
  async _updateMetadata() {
    try {
      const now = new Date();
      const metadata = {
        lastUpdateTime: now.toISOString(),
        source: this.snortRulesUrl,
        ruleCount: this._countRules(),
        customRuleCount: this._countCustomRules(),
        pluginId: this.pluginId
      };
      
      const metadataPath = path.join(this.rulesDirectory, 'metadata.json');
      fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
      
      this.lastUpdateTime = now;
      this.logger.info('Updated rules metadata', { lastUpdateTime: now });
    } catch (error) {
      throw new Error(`Failed to update rules metadata: ${error.message}`);
    }
  }
  
  /**
   * Count the number of rules
   * @returns {number} - Number of rules
   * @private
   */
  _countRules() {
    try {
      let count = 0;
      
      const ruleFiles = fs.readdirSync(this.rulesDirectory)
        .filter(file => file.endsWith('.rules'));
      
      for (const file of ruleFiles) {
        const content = fs.readFileSync(path.join(this.rulesDirectory, file), 'utf8');
        const lines = content.split('\n');
        count += lines.filter(line => line.trim().startsWith('alert')).length;
      }
      
      return count;
    } catch (error) {
      this.logger.error('Error counting rules', { error: error.message });
      return 0;
    }
  }
  
  /**
   * Count the number of custom rules
   * @returns {number} - Number of custom rules
   * @private
   */
  _countCustomRules() {
    try {
      if (!fs.existsSync(this.customRulesDirectory)) {
        return 0;
      }
      
      let count = 0;
      
      const ruleFiles = fs.readdirSync(this.customRulesDirectory)
        .filter(file => file.endsWith('.rules'));
      
      for (const file of ruleFiles) {
        const content = fs.readFileSync(path.join(this.customRulesDirectory, file), 'utf8');
        const lines = content.split('\n');
        count += lines.filter(line => line.trim().startsWith('alert')).length;
      }
      
      return count;
    } catch (error) {
      this.logger.error('Error counting custom rules', { error: error.message });
      return 0;
    }
  }
  
  /**
   * Restore rules from backup
   * @private
   */
  async _restoreFromBackup() {
    try {
      // Get latest backup
      const backupDirs = fs.readdirSync(this.backupDirectory);
      
      if (backupDirs.length === 0) {
        this.logger.warn('No backups found to restore from');
        return;
      }
      
      // Sort by name (which includes timestamp) to get the latest backup
      backupDirs.sort().reverse();
      const latestBackup = backupDirs[0];
      const backupPath = path.join(this.backupDirectory, latestBackup);
      
      this.logger.info(`Restoring rules from backup: ${latestBackup}`);
      
      // Copy rule files from backup
      const backupFiles = fs.readdirSync(backupPath);
      for (const file of backupFiles) {
        const sourcePath = path.join(backupPath, file);
        const destPath = path.join(this.rulesDirectory, file);
        fs.copyFileSync(sourcePath, destPath);
      }
      
      // Update last update time from restored metadata
      await this._getLastUpdateTime();
      
      this.logger.info('Successfully restored rules from backup');
    } catch (error) {
      throw new Error(`Failed to restore from backup: ${error.message}`);
    }
  }
  
  /**
   * Schedule the next rules update
   * @private
   */
  _scheduleNextUpdate() {
    // Clear any existing timer
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    
    // Calculate time until next update
    let timeUntilNextUpdate = this.updateInterval;
    if (this.lastUpdateTime) {
      const timeSinceLastUpdate = Date.now() - this.lastUpdateTime.getTime();
      timeUntilNextUpdate = Math.max(0, this.updateInterval - timeSinceLastUpdate);
    }
    
    // Schedule next update
    this.updateTimer = setTimeout(() => {
      this.updateRules().catch(error => {
        this.logger.error('Scheduled rules update failed', { error: error.message });
      });
    }, timeUntilNextUpdate);
    
    const nextUpdateTime = new Date(Date.now() + timeUntilNextUpdate);
    this.logger.info('Scheduled next rules update', { 
      nextUpdateTime,
      timeUntilNextUpdate: Math.floor(timeUntilNextUpdate / 1000 / 60) + ' minutes'
    });
  }
  
  /**
   * Add a custom rule
   * @param {string} rule - The rule to add
   * @param {string} filename - Name of the file to add the rule to
   * @returns {Promise<boolean>} - True if the rule was added successfully
   */
  async addCustomRule(rule, filename = 'custom.rules') {
    try {
      if (!rule.trim().startsWith('alert')) {
        throw new Error('Invalid rule format, must start with "alert"');
      }
      
      // Ensure custom rules directory exists
      if (!fs.existsSync(this.customRulesDirectory)) {
        fs.mkdirSync(this.customRulesDirectory, { recursive: true });
      }
      
      const ruleFilePath = path.join(this.customRulesDirectory, filename);
      
      // Add rule to file with newline
      const ruleWithNewline = rule.endsWith('\n') ? rule : rule + '\n';
      fs.appendFileSync(ruleFilePath, ruleWithNewline);
      
      this.logger.info('Added custom rule', { filename });
      
      // Update metadata to reflect new rule count
      await this._updateMetadata();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to add custom rule', { error: error.message, rule });
      throw error;
    }
  }
  
  /**
   * Get last update time
   * @returns {Date|null} - Last update time or null if never updated
   */
  getLastUpdateTime() {
    return this.lastUpdateTime;
  }
  
  /**
   * Get rules statistics
   * @returns {Object} - Rules statistics
   */
  getRulesStats() {
    return {
      lastUpdateTime: this.lastUpdateTime,
      ruleCount: this._countRules(),
      customRuleCount: this._countCustomRules(),
      nextUpdateTime: this.updateTimer ? new Date(Date.now() + this.updateTimer._idleTimeout) : null
    };
  }
  
  /**
   * Stop the rules manager and clean up
   * @returns {Promise<boolean>} - True if cleanup was successful
   */
  async stop() {
    // Clear update timer
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    
    this.logger.info('SnortRulesManager stopped');
    return true;
  }
}

module.exports = SnortRulesManager;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { z } = require('zod');

/**
 * Zod schema for the Penitent collection
 * 
 * This schema defines the structure and validation rules for the
 * Penitent collection, which stores queued security testing tasks.
 */
const PenitentSchema = z.object({
  // Core fields
  _id: z.string().optional(), // MongoDB will generate this
  taskType: z.enum(['scan', 'pentest', 'self-heal']),
  status: z.enum(['pending', 'processing', 'completed', 'failed', 'cancelled']),
  priority: z.enum(['low', 'normal', 'high', 'critical']),
  
  // Target information
  targetId: z.string(),
  targetType: z.enum(['local', 'remote', 'core']).optional(),
  targetAddress: z.string().optional(),
  
  // Task-specific fields for scan tasks
  scanType: z.enum(['nmap', 'snort', 'vulnerability', 'compliance']).optional(),
  scanOptions: z.object({}).passthrough().optional(),
  
  // Task-specific fields for pentest tasks
  testType: z.enum(['basic', 'comprehensive', 'focused', 'pressureTest']).optional(),
  testOptions: z.object({}).passthrough().optional(),
  
  // Task-specific fields for self-heal tasks
  vulnerabilityId: z.string().optional(),
  vulnerabilityDetails: z.object({}).passthrough().optional(),
  remediationStrategy: z.string().optional(),
  
  // Request tracking for distributed tasks
  requestId: z.string().optional(),
  sourceId: z.string().optional(),
  
  // Timing information
  createdAt: z.date(),
  scheduledTime: z.date(),
  startedAt: z.date().optional(),
  completedAt: z.date().optional(),
  
  // Results and error information
  results: z.object({}).passthrough().optional(),
  error: z.string().optional(),
  
  // Metadata
  tags: z.array(z.string()).optional(),
  notes: z.string().optional()
});

/**
 * PenitentModel - Model class for Penitent collection entries
 * 
 * This class represents an entry in the Penitent collection, providing
 * type safety and validation using Zod.
 */
class PenitentModel {
  /**
   * Constructor for PenitentModel
   * @param {Object} data - The data to initialize the model with
   */
  constructor(data) {
    // Set default values
    const defaultValues = {
      status: 'pending',
      priority: 'normal',
      createdAt: new Date(),
      scheduledTime: new Date()
    };
    
    // Merge defaults with provided data
    const mergedData = { ...defaultValues, ...data };
    
    // Validate against schema
    const validatedData = PenitentSchema.parse(mergedData);
    
    // Assign validated data to instance
    Object.assign(this, validatedData);
  }
  
  /**
   * Validate a penitent object against the schema
   * @param {Object} data - The data to validate
   * @returns {Object} - The validated data
   * @throws {Error} - If validation fails
   */
  static validate(data) {
    return PenitentSchema.parse(data);
  }
  
  /**
   * Create a scan task
   * @param {Object} options - Scan task options
   * @returns {PenitentModel} - New penitent model instance
   */
  static createScanTask(options) {
    return new PenitentModel({
      taskType: 'scan',
      scanType: options.scanType,
      scanOptions: options.scanOptions,
      targetId: options.targetId,
      priority: options.priority || 'normal',
      scheduledTime: options.scheduledTime || new Date()
    });
  }
  
  /**
   * Create a pentest task
   * @param {Object} options - Pentest task options
   * @returns {PenitentModel} - New penitent model instance
   */
  static createPentestTask(options) {
    return new PenitentModel({
      taskType: 'pentest',
      testType: options.testType,
      testOptions: options.testOptions,
      targetId: options.targetId,
      sourceId: options.sourceId,
      requestId: options.requestId,
      priority: options.priority || 'high',
      scheduledTime: options.scheduledTime || new Date()
    });
  }
  
  /**
   * Create a self-heal task
   * @param {Object} options - Self-heal task options
   * @returns {PenitentModel} - New penitent model instance
   */
  static createSelfHealTask(options) {
    return new PenitentModel({
      taskType: 'self-heal',
      vulnerabilityId: options.vulnerabilityId,
      vulnerabilityDetails: options.vulnerabilityDetails,
      remediationStrategy: options.remediationStrategy,
      targetId: options.targetId,
      priority: options.priority || 'critical',
      scheduledTime: options.scheduledTime || new Date()
    });
  }
}

module.exports = { PenitentModel, PenitentSchema };
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { spawn } = require('child_process');

/**
 * ScannerManager - Manages security scanning tools
 * 
 * This class handles various security scanning tools like Nmap and Snort,
 * providing a unified interface for running security scans and tests.
 */
class ScannerManager {
  /**
   * Constructor for ScannerManager
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Scanner configuration
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = options.config || {};
    this.pluginId = options.pluginId;
    this.scanResultsDir = path.resolve(process.cwd(), 'private/plugins/modules/pentest/scan-results');
    this.nmapConfig = this.config.nmap || {};
    this.snortConfig = this.config.snort || {};
    this.isSnortRunning = false;
    this.snortProcess = null;
    this.activeScans = new Map();
  }
  
  /**
   * Initialize the scanner manager
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing ScannerManager');
      
      // Create scan results directory if it doesn't exist
      if (!fs.existsSync(this.scanResultsDir)) {
        fs.mkdirSync(this.scanResultsDir, { recursive: true });
        this.logger.info(`Created scan results directory: ${this.scanResultsDir}`);
      }
      
      // Check if required tools are available
      await this._checkToolAvailability();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize ScannerManager', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Check if required security tools are available
   * @private
   */
  async _checkToolAvailability() {
    try {
      // Check for Nmap if enabled
      if (this.nmapConfig.enabled) {
        try {
          const { stdout } = await exec('nmap --version');
          this.logger.info(`Nmap is available: ${stdout.split('\n')[0]}`);
        } catch (error) {
          this.logger.warn('Nmap is not available in the system path, some scans will be limited');
          this.nmapConfig.enabled = false;
        }
      }
      
      // For Snort, we'll use the Docker container or check for local installation
      if (this.snortConfig.enabled) {
        if (this.config.useDocker) {
          this.logger.info('Snort will be used via Docker container');
        } else {
          try {
            const { stdout } = await exec('snort --version');
            this.logger.info(`Snort is available: ${stdout.split('\n')[0]}`);
          } catch (error) {
            this.logger.warn('Snort is not available in the system path, will use Docker container instead');
            this.config.useDocker = true;
          }
        }
      }
    } catch (error) {
      throw new Error(`Failed to check tool availability: ${error.message}`);
    }
  }
  
  /**
   * Run an Nmap scan
   * @param {Object} options - Scan options
   * @param {string} target - Target to scan
   * @returns {Promise<Object>} - Scan results
   */
  async runNmapScan(options, target) {
    if (!this.nmapConfig.enabled) {
      throw new Error('Nmap scanning is not enabled');
    }
    
    const scanId = crypto.randomBytes(8).toString('hex');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const outputFile = path.join(this.scanResultsDir, `nmap-scan-${timestamp}-${scanId}.xml`);
    
    try {
      this.logger.info('Starting Nmap scan', { scanId, target, options });
      
      // Build the Nmap command
      let scanOptions = options.scanOptions || this.nmapConfig.defaultOptions || '-sV';
      if (!scanOptions.includes('-oX')) {
        scanOptions += ` -oX ${outputFile}`;
      }
      
      const targetAddress = target === 'local' || target === 'localhost' ? 
        'localhost' : (options.targetAddress || target);
      
      const command = `nmap ${scanOptions} ${targetAddress}`;
      
      this.logger.debug('Nmap command', { command });
      
      // Add to active scans
      this.activeScans.set(scanId, {
        type: 'nmap',
        target: targetAddress,
        options: scanOptions,
        startTime: new Date(),
        status: 'running'
      });
      
      // Execute the command
      const { stdout, stderr } = await exec(command);
      
      // Read the XML output
      const xmlOutput = fs.readFileSync(outputFile, 'utf8');
      
      // Parse XML to JSON (simplified here, would use a proper XML parser in production)
      const results = await this._parseNmapXml(xmlOutput);
      
      // Update scan status
      this.activeScans.set(scanId, {
        ...this.activeScans.get(scanId),
        status: 'completed',
        endTime: new Date()
      });
      
      this.logger.info('Nmap scan completed', { scanId });
      
      return {
        scanId,
        target: targetAddress,
        timestamp: new Date(),
        results,
        raw: {
          stdout,
          stderr,
          xmlOutput
        },
        outputFile
      };
    } catch (error) {
      // Update scan status
      if (this.activeScans.has(scanId)) {
        this.activeScans.set(scanId, {
          ...this.activeScans.get(scanId),
          status: 'failed',
          endTime: new Date(),
          error: error.message
        });
      }
      
      this.logger.error('Nmap scan failed', { error: error.message, scanId, target });
      throw error;
    }
  }
  
  /**
   * Parse Nmap XML output to JSON
   * @param {string} xml - XML output from Nmap
   * @returns {Promise<Object>} - Parsed scan results
   * @private
   */
  async _parseNmapXml(xml) {
    // In a real implementation, use a proper XML parser
    // This is a simplified example
    try {
      // Extract basic information from the XML
      const hostMatches = xml.match(/<host\s+[^>]*>([\s\S]*?)<\/host>/g) || [];
      
      const hosts = hostMatches.map(hostXml => {
        // Extract address
        const addressMatch = hostXml.match(/<address\s+addr="([^"]+)"\s+addrtype="([^"]+)"/);
        const address = addressMatch ? addressMatch[1] : null;
        const addrtype = addressMatch ? addressMatch[2] : null;
        
        // Extract host status
        const statusMatch = hostXml.match(/<status\s+state="([^"]+)"/);
        const state = statusMatch ? statusMatch[1] : null;
        
        // Extract ports
        const portMatches = hostXml.match(/<port\s+[^>]*>([\s\S]*?)<\/port>/g) || [];
        const ports = portMatches.map(portXml => {
          const portIdMatch = portXml.match(/portid="(\d+)"/);
          const protocolMatch = portXml.match(/protocol="([^"]+)"/);
          const stateMatch = portXml.match(/<state\s+state="([^"]+)"/);
          const serviceMatch = portXml.match(/<service\s+name="([^"]+)"\s+[^>]*>/);
          
          return {
            port: portIdMatch ? parseInt(portIdMatch[1]) : null,
            protocol: protocolMatch ? protocolMatch[1] : null,
            state: stateMatch ? stateMatch[1] : null,
            service: serviceMatch ? serviceMatch[1] : null
          };
        });
        
        return {
          address,
          addrtype,
          state,
          ports
        };
      });
      
      return {
        hosts,
        summary: {
          totalHosts: hosts.length,
          upHosts: hosts.filter(h => h.state === 'up').length,
          openPorts: hosts.reduce((sum, host) => sum + host.ports.filter(p => p.state === 'open').length, 0)
        }
      };
    } catch (error) {
      this.logger.error('Error parsing Nmap XML', { error: error.message });
      throw new Error(`Failed to parse Nmap XML: ${error.message}`);
    }
  }
  
  /**
   * Start Snort detection
   * @returns {Promise<boolean>} - True if Snort was started successfully
   */
  async startSnort() {
    if (!this.snortConfig.enabled) {
      this.logger.info('Snort detection is not enabled');
      return false;
    }
    
    if (this.isSnortRunning) {
      this.logger.info('Snort is already running');
      return true;
    }
    
    try {
      this.logger.info('Starting Snort detection');
      
      if (this.config.useDocker) {
        // If using Docker, we just verify the container is running
        // The actual Snort command will be executed inside the container
        this.logger.info('Using Docker container for Snort');
        this.isSnortRunning = true;
        return true;
      } else {
        // Start Snort directly on the host
        const configFile = this.snortConfig.configFile;
        const interfaces = this.snortConfig.interfaces || ['eth0'];
        const logDir = path.join(this.scanResultsDir, 'snort-logs');
        
        // Create log directory if it doesn't exist
        if (!fs.existsSync(logDir)) {
          fs.mkdirSync(logDir, { recursive: true });
        }
        
        // Build the Snort command
        const command = `snort -c ${configFile} -i ${interfaces[0]} -l ${logDir} -A console`;
        
        this.logger.debug('Snort command', { command });
        
        // Start Snort as a background process
        const snortProcess = spawn('snort', [
          '-c', configFile,
          '-i', interfaces[0],
          '-l', logDir,
          '-A', 'console'
        ]);
        
        this.snortProcess = snortProcess;
        
        // Handle process events
        snortProcess.stdout.on('data', (data) => {
          this.logger.debug('Snort output', { data: data.toString() });
        });
        
        snortProcess.stderr.on('data', (data) => {
          this.logger.debug('Snort error', { data: data.toString() });
        });
        
        snortProcess.on('close', (code) => {
          this.logger.info('Snort process closed', { code });
          this.isSnortRunning = false;
          this.snortProcess = null;
        });
        
        this.isSnortRunning = true;
        this.logger.info('Snort detection started successfully');
        
        return true;
      }
    } catch (error) {
      this.logger.error('Failed to start Snort', { error: error.message });
      this.isSnortRunning = false;
      this.snortProcess = null;
      throw error;
    }
  }
  
  /**
   * Stop Snort detection
   * @returns {Promise<boolean>} - True if Snort was stopped successfully
   */
  async stopSnort() {
    if (!this.isSnortRunning) {
      this.logger.info('Snort is not running');
      return true;
    }
    
    try {
      this.logger.info('Stopping Snort detection');
      
      if (this.config.useDocker) {
        // If using Docker, we don't need to do anything here
        // The container is managed separately
        this.logger.info('Snort in Docker container will be managed by container manager');
      } else if (this.snortProcess) {
        // Kill the Snort process
        this.snortProcess.kill('SIGTERM');
        
        // Wait for process to terminate
        await new Promise(resolve => {
          this.snortProcess.on('exit', () => {
            resolve();
          });
          
          // Force kill after timeout
          setTimeout(() => {
            if (this.snortProcess) {
              this.snortProcess.kill('SIGKILL');
              resolve();
            }
          }, 5000);
        });
      }
      
      this.isSnortRunning = false;
      this.snortProcess = null;
      this.logger.info('Snort detection stopped successfully');
      
      return true;
    } catch (error) {
      this.logger.error('Failed to stop Snort', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Run Snort detection on captured traffic or a pcap file
   * @param {Object} options - Detection options
   * @returns {Promise<Object>} - Detection results
   */
  async runSnortDetection(options) {
    if (!this.snortConfig.enabled) {
      throw new Error('Snort detection is not enabled');
    }
    
    const detectionId = crypto.randomBytes(8).toString('hex');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const outputFile = path.join(this.scanResultsDir, `snort-detection-${timestamp}-${detectionId}.log`);
    
    try {
      this.logger.info('Starting Snort detection', { detectionId, options });
      
      let command;
      if (this.config.useDocker) {
        // If using Docker, run Snort inside the container
        const pcapFile = options.pcapFile ? path.basename(options.pcapFile) : null;
        const pcapPath = options.pcapFile ? `/pcaps/${pcapFile}` : null;
        
        if (pcapFile) {
          command = `docker exec pentest-snort-container snort -c /etc/snort/snort.conf -r ${pcapPath} -A csv -l /var/log/snort`;
        } else {
          // Just check the current status for live traffic
          command = 'docker exec pentest-snort-container cat /var/log/snort/alert.csv';
        }
      } else {
        // Run Snort directly on the host
        const configFile = options.configFile || this.snortConfig.configFile;
        
        if (options.pcapFile) {
          command = `snort -c ${configFile} -r ${options.pcapFile} -A csv -l ${path.dirname(outputFile)}`;
        } else {
          // Just check the current logs
          const logDir = path.join(this.scanResultsDir, 'snort-logs');
          command = `cat ${logDir}/alert.csv`;
        }
      }
      
      this.logger.debug('Snort command', { command });
      
      // Execute the command
      const { stdout, stderr } = await exec(command);
      
      // Parse the output
      const alerts = this._parseSnortOutput(stdout);
      
      this.logger.info('Snort detection completed', { 
        detectionId,
        alertCount: alerts.length
      });
      
      return {
        detectionId,
        timestamp: new Date(),
        alerts,
        summary: {
          total: alerts.length,
          critical: alerts.filter(a => a.priority === 1).length,
          high: alerts.filter(a => a.priority === 2).length,
          medium: alerts.filter(a => a.priority === 3).length,
          low: alerts.filter(a => a.priority >= 4).length
        },
        raw: {
          stdout,
          stderr
        }
      };
    } catch (error) {
      this.logger.error('Snort detection failed', { 
        error: error.message,
        detectionId
      });
      throw error;
    }
  }
  
  /**
   * Parse Snort output
   * @param {string} output - Snort output
   * @returns {Array} - Parsed alerts
   * @private
   */
  _parseSnortOutput(output) {
    try {
      // Handle empty output
      if (!output || output.trim() === '') {
        return [];
      }
      
      // Parse CSV format
      const lines = output.split('\n').filter(line => line.trim() !== '');
      
      return lines.map(line => {
        const parts = line.split(',');
        
        // Handle different formats
        if (parts.length >= 6) {
          // Standard CSV format
          return {
            timestamp: parts[0],
            signatureId: parts[1],
            generator: parts[2],
            signature: parts[3],
            priority: parseInt(parts[4]),
            sourceIp: parts[5],
            destinationIp: parts[6],
            protocol: parts[7],
            sourcePort: parts[8] ? parseInt(parts[8]) : null,
            destinationPort: parts[9] ? parseInt(parts[9]) : null
          };
        } else {
          // Legacy or custom format
          return {
            raw: line,
            timestamp: new Date().toISOString(),
            priority: line.includes('Priority: ') ? 
              parseInt(line.match(/Priority: (\d+)/)[1]) : 3,
            signature: line.includes('[**] ') ? 
              line.match(/\[\*\*\] (.*?) \[\*\*\]/)[1] : line
          };
        }
      });
    } catch (error) {
      this.logger.error('Error parsing Snort output', { error: error.message });
      return [];
    }
  }
  
  /**
   * Run a comprehensive penetration test
   * @param {string} testType - Type of test to run
   * @param {Object} options - Test options
   * @param {string} target - Target to test
   * @returns {Promise<Object>} - Test results
   */
  async runComprehensivePentest(testType, options, target) {
    try {
      this.logger.info('Starting comprehensive penetration test', { 
        testType,
        target,
        options
      });
      
      const targetAddress = target === 'local' || target === 'localhost' ? 
        'localhost' : (options.targetAddress || target);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const pentestId = crypto.randomBytes(8).toString('hex');
      const resultsDir = path.join(this.scanResultsDir, `pentest-${timestamp}-${pentestId}`);
      
      // Create results directory
      fs.mkdirSync(resultsDir, { recursive: true });
      
      // Determine which tests to run based on test type
      const testPlan = this._createTestPlan(testType, options, targetAddress);
      
      // Run the tests in sequence
      const results = {
        pentestId,
        target: targetAddress,
        timestamp: new Date(),
        testType,
        testResults: {},
        vulnerabilities: [],
        summary: {}
      };
      
      for (const test of testPlan) {
        try {
          this.logger.info(`Running test: ${test.name}`, { target: targetAddress });
          
          // Run the test
          const testResult = await this._runTest(test, targetAddress, resultsDir);
          
          // Store the result
          results.testResults[test.name] = testResult;
          
          // Add vulnerabilities to the combined list
          if (testResult.vulnerabilities && Array.isArray(testResult.vulnerabilities)) {
            results.vulnerabilities = [
              ...results.vulnerabilities,
              ...testResult.vulnerabilities
            ];
          }
          
          this.logger.info(`Completed test: ${test.name}`, {
            vulnerabilitiesFound: testResult.vulnerabilities ? testResult.vulnerabilities.length : 0
          });
        } catch (error) {
          this.logger.error(`Test failed: ${test.name}`, { error: error.message });
          
          // Store the error
          results.testResults[test.name] = {
            status: 'failed',
            error: error.message
          };
        }
      }
      
      // Generate summary
      results.summary = this._generatePentestSummary(results);
      
      this.logger.info('Comprehensive penetration test completed', {
        pentestId,
        target: targetAddress,
        vulnerabilitiesFound: results.vulnerabilities.length
      });
      
      return results;
    } catch (error) {
      this.logger.error('Comprehensive penetration test failed', { 
        error: error.message,
        testType,
        target
      });
      throw error;
    }
  }
  
  /**
   * Create a test plan based on test type
   * @param {string} testType - Type of test to run
   * @param {Object} options - Test options
   * @param {string} target - Target to test
   * @returns {Array} - Test plan
   * @private
   */
  _createTestPlan(testType, options, target) {
    const plan = [];
    
    switch (testType) {
      case 'basic':
        // Basic test plan
        plan.push({
          name: 'portScan',
          description: 'Basic port scan',
          tool: 'nmap',
          options: '-sV -F --open'
        });
        break;
        
      case 'comprehensive':
        // Comprehensive test plan
        plan.push({
          name: 'portScan',
          description: 'Comprehensive port scan',
          tool: 'nmap',
          options: '-sV -sC -O -p-'
        });
        
        plan.push({
          name: 'vulnerabilityScan',
          description: 'Vulnerability scan',
          tool: 'nmap',
          options: '--script vuln'
        });
        
        plan.push({
          name: 'trafficAnalysis',
          description: 'Network traffic analysis',
          tool: 'snort',
          options: {}
        });
        break;
        
      case 'focused':
        // Focused test plan based on options
        if (options.services && options.services.includes('web')) {
          plan.push({
            name: 'webScan',
            description: 'Web service scan',
            tool: 'nmap',
            options: '-p 80,443,8080,8443 --script http-enum,http-headers,http-methods,http-auth'
          });
        }
        
        if (options.services && options.services.includes('ssh')) {
          plan.push({
            name: 'sshScan',
            description: 'SSH service scan',
            tool: 'nmap',
            options: '-p 22 --script ssh-auth-methods,ssh-hostkey,ssh-brute'
          });
        }
        
        if (options.services && options.services.includes('dns')) {
          plan.push({
            name: 'dnsScan',
            description: 'DNS service scan',
            tool: 'nmap',
            options: '-p 53 --script dns-recursion,dns-service-discovery,dns-cache-snoop'
          });
        }
        break;
        
      case 'pressureTest':
        // Pressure test plan
        plan.push({
          name: 'portScan',
          description: 'Comprehensive port scan',
          tool: 'nmap',
          options: '-sV -sC -O -p-'
        });
        
        plan.push({
          name: 'vulnerabilityScan',
          description: 'Vulnerability scan',
          tool: 'nmap',
          options: '--script vuln'
        });
        
        plan.push({
          name: 'trafficAnalysis',
          description: 'Network traffic analysis',
          tool: 'snort',
          options: {}
        });
        break;
        
      default:
        // Default test plan
        plan.push({
          name: 'portScan',
          description: 'Basic port scan',
          tool: 'nmap',
          options: '-sV -F --open'
        });
    }
    
    return plan;
  }
  
  /**
   * Run an individual test
   * @param {Object} test - Test to run
   * @param {string} target - Target to test
   * @param {string} resultsDir - Directory to store results
   * @returns {Promise<Object>} - Test results
   * @private
   */
  async _runTest(test, target, resultsDir) {
    try {
      switch (test.tool) {
        case 'nmap':
          // Run Nmap scan
          const nmapResults = await this.runNmapScan({ 
            scanOptions: test.options,
            targetAddress: target
          }, target);
          
          // Process Nmap results into vulnerabilities
          const vulnerabilities = this._extractVulnerabilitiesFromNmap(nmapResults);
          
          return {
            ...nmapResults,
            vulnerabilities
          };
          
        case 'snort':
          // Run Snort detection
          const snortResults = await this.runSnortDetection(test.options);
          
          // Process Snort results into vulnerabilities
          const snortVulnerabilities = this._extractVulnerabilitiesFromSnort(snortResults);
          
          return {
            ...snortResults,
            vulnerabilities: snortVulnerabilities
          };
          
        default:
          throw new Error(`Unsupported test tool: ${test.tool}`);
      }
    } catch (error) {
      this.logger.error(`Test run failed: ${test.name}`, { error: error.message });
      throw error;
    }
  }
  
  /**
   * Extract vulnerabilities from Nmap scan results
   * @param {Object} nmapResults - Nmap scan results
   * @returns {Array} - Vulnerabilities
   * @private
   */
  _extractVulnerabilitiesFromNmap(nmapResults) {
    const vulnerabilities = [];
    
    try {
      // Process host information
      for (const host of nmapResults.results.hosts) {
        // Skip hosts that are not up
        if (host.state !== 'up') continue;
        
        // Check for open ports
        for (const port of host.ports) {
          // Skip closed ports
          if (port.state !== 'open') continue;
          
          // Generate vulnerability ID
          const vulnId = crypto.createHash('md5')
            .update(`${host.address}:${port.port}:${port.service}`)
            .digest('hex');
          
          // Determine severity based on service and port
          let severity = 'low';
          
          // Check for common high-risk services
          if (this._isHighRiskService(port.service, port.port)) {
            severity = 'high';
          } else if (this._isMediumRiskService(port.service, port.port)) {
            severity = 'medium';
          }
          
          // Create vulnerability record
          vulnerabilities.push({
            id: vulnId,
            type: 'open_port',
            subtype: port.service,
            severity,
            target: host.address,
            details: {
              port: port.port,
              protocol: port.protocol,
              service: port.service,
              state: port.state
            },
            description: `Open ${port.service || 'unknown'} service on port ${port.port}/${port.protocol}`,
            remediation: this._getRemediationForOpenPort(port.service, port.port),
            remediationStrategy: this._getRemediationStrategy(port.service, port.port)
          });
        }
      }
    } catch (error) {
      this.logger.error('Error extracting vulnerabilities from Nmap results', { 
        error: error.message 
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Check if a service is high risk
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {boolean} - True if the service is high risk
   * @private
   */
  _isHighRiskService(service, port) {
    const highRiskServices = [
      'ms-sql', 'oracle', 'mysql', 'postgresql', 'mongodb',  // Databases
      'ftp', 'telnet', 'rsh', 'rlogin',                      // Unencrypted services
      'vnc', 'rdp',                                          // Remote access
      'smb', 'netbios',                                      // Windows sharing
      'redis', 'memcached',                                  // Caches often misconfigured
      'irc'                                                  // IRC service
    ];
    
    const highRiskPorts = [
      3389,  // RDP
      21,    // FTP
      23,    // Telnet
      445,   // SMB
      137,   // NetBIOS
      138,   // NetBIOS
      139,   // NetBIOS
      5900,  // VNC
      6379,  // Redis
      11211, // Memcached
      9200,  // Elasticsearch
      8080,  // Common proxy/web port
      8443   // Common proxy/web port
    ];
    
    return highRiskServices.includes(service) || highRiskPorts.includes(port);
  }
  
  /**
   * Check if a service is medium risk
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {boolean} - True if the service is medium risk
   * @private
   */
  _isMediumRiskService(service, port) {
    const mediumRiskServices = [
      'http', 'https',                        // Web servers
      'ssh',                                  // SSH
      'smtp', 'imap', 'pop3',                 // Mail
      'dns',                                  // DNS
      'nfs', 'samba',                         // File sharing
      'snmp'                                  // SNMP
    ];
    
    const mediumRiskPorts = [
      80,    // HTTP
      443,   // HTTPS
      22,    // SSH
      25,    // SMTP
      53,    // DNS
      123,   // NTP
      161,   // SNMP
      2049   // NFS
    ];
    
    return mediumRiskServices.includes(service) || mediumRiskPorts.includes(port);
  }
  
  /**
   * Get remediation recommendation for an open port
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {string} - Remediation recommendation
   * @private
   */
  _getRemediationForOpenPort(service, port) {
    // Default remediation
    let remediation = `Consider whether port ${port} needs to be exposed. If not, close it or restrict access using firewall rules.`;
    
    // Service-specific remediations
    switch (service) {
      case 'http':
      case 'https':
        remediation = `Ensure that the web server on port ${port} is running the latest version with all security patches applied. Configure TLS properly if HTTPS is used. Consider using a web application firewall (WAF).`;
        break;
        
      case 'ssh':
        remediation = `Ensure SSH on port ${port} is configured securely: disable root login, use key-based authentication, limit user access, and consider changing to a non-standard port.`;
        break;
        
      case 'ftp':
        remediation = `FTP service on port ${port} transmits data in cleartext. Consider replacing with SFTP or FTPS, or restrict access to trusted IPs only.`;
        break;
        
      case 'telnet':
        remediation = `Telnet on port ${port} is insecure and transmits data in cleartext. Replace with SSH for secure remote access.`;
        break;
        
      case 'smtp':
      case 'imap':
      case 'pop3':
        remediation = `Ensure mail services on port ${port} are configured securely. Use encrypted versions (IMAPS, POP3S) and restrict access if possible.`;
        break;
        
      case 'rdp':
        remediation = `Restrict RDP access on port ${port} using firewall rules, enable Network Level Authentication, use strong passwords, and keep the service updated.`;
        break;
        
      case 'mysql':
      case 'ms-sql':
      case 'postgresql':
      case 'mongodb':
      case 'oracle':
        remediation = `Database service on port ${port} should not be directly exposed to the internet. Use a firewall to restrict access to trusted IPs only, enforce strong authentication, and keep the database updated.`;
        break;
        
      case 'redis':
      case 'memcached':
        remediation = `Cache service on port ${port} should not be exposed to the internet. Bind to localhost only or use firewall rules to restrict access, and configure authentication if available.`;
        break;
    }
    
    return remediation;
  }
  
  /**
   * Get remediation strategy for an open port
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {string} - Remediation strategy
   * @private
   */
  _getRemediationStrategy(service, port) {
    // Define remediation strategies for automated healing
    // These would be commands or scripts to run for remediation
    
    // Default strategy is just a description as automatic remediation may be risky
    return `restrict_port:${port}`;
  }
  
  /**
   * Extract vulnerabilities from Snort results
   * @param {Object} snortResults - Snort detection results
   * @returns {Array} - Vulnerabilities
   * @private
   */
  _extractVulnerabilitiesFromSnort(snortResults) {
    const vulnerabilities = [];
    
    try {
      // Process alerts
      for (const alert of snortResults.alerts) {
        // Generate vulnerability ID
        const vulnId = crypto.createHash('md5')
          .update(`snort:${alert.signatureId || alert.signature}:${alert.sourceIp || ''}:${alert.destinationIp || ''}`)
          .digest('hex');
        
        // Map Snort priority to severity
        let severity;
        switch (alert.priority) {
          case 1:
            severity = 'critical';
            break;
          case 2:
            severity = 'high';
            break;
          case 3:
            severity = 'medium';
            break;
          default:
            severity = 'low';
        }
        
        // Create vulnerability record
        vulnerabilities.push({
          id: vulnId,
          type: 'intrusion_attempt',
          subtype: alert.generator || 'snort',
          severity,
          target: alert.destinationIp || 'unknown',
          source: alert.sourceIp || 'unknown',
          details: {
            signature: alert.signature,
            signatureId: alert.signatureId,
            protocol: alert.protocol,
            sourcePort: alert.sourcePort,
            destinationPort: alert.destinationPort,
            timestamp: alert.timestamp
          },
          description: alert.signature || 'Unknown intrusion attempt',
          remediation: this._getRemediationForIntrusion(alert),
          remediationStrategy: this._getRemediationStrategyForIntrusion(alert)
        });
      }
    } catch (error) {
      this.logger.error('Error extracting vulnerabilities from Snort results', { 
        error: error.message 
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Get remediation recommendation for an intrusion alert
   * @param {Object} alert - Snort alert
   * @returns {string} - Remediation recommendation
   * @private
   */
  _getRemediationForIntrusion(alert) {
    // Default remediation
    let remediation = `Investigate the traffic between ${alert.sourceIp || 'unknown'} and ${alert.destinationIp || 'unknown'} that triggered the alert "${alert.signature || 'unknown'}".`;
    
    // Add more specific recommendations based on the alert signature
    if (alert.signature) {
      const signature = alert.signature.toLowerCase();
      
      if (signature.includes('scan') || signature.includes('reconnaissance')) {
        remediation += ' This appears to be a reconnaissance attempt. Consider blocking the source IP if it's not a legitimate source.';
      } else if (signature.includes('exploit') || signature.includes('overflow') || signature.includes('injection')) {
        remediation += ' This appears to be an exploit attempt. Ensure the target system is patched and consider blocking the source IP.';
      } else if (signature.includes('dos') || signature.includes('denial of service')) {
        remediation += ' This appears to be a denial of service attempt. Consider implementing rate limiting and blocking the source IP.';
      } else if (signature.includes('malware') || signature.includes('trojan') || signature.includes('virus')) {
        remediation += ' This appears to be malware-related traffic. Scan the target system for malware and consider blocking the source IP.';
      }
    }
    
    return remediation;
  }
  
  /**
   * Get remediation strategy for an intrusion alert
   * @param {Object} alert - Snort alert
   * @returns {string} - Remediation strategy
   * @private
   */
  _getRemediationStrategyForIntrusion(alert) {
    // Default strategy is just a description as automatic remediation may be risky
    return `block_ip:${alert.sourceIp || 'unknown'}`;
  }
  
  /**
   * Generate a summary of the penetration test results
   * @param {Object} results - Test results
   * @returns {Object} - Summary
   * @private
   */
  _generatePentestSummary(results) {
    // Count vulnerabilities by severity
    const severityCounts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };
    
    // Count vulnerabilities by type
    const typeCounts = {};
    
    // Process vulnerabilities
    for (const vuln of results.vulnerabilities) {
      // Count by severity
      if (severityCounts[vuln.severity] !== undefined) {
        severityCounts[vuln.severity]++;
      } else {
        severityCounts.info++;
      }
      
      // Count by type
      const type = vuln.type || 'unknown';
      typeCounts[type] = (typeCounts[type] || 0) + 1;
    }
    
    // Calculate risk score (0-100)
    // Weighted by severity: critical=40, high=30, medium=20, low=10
    const totalVulnerabilities = results.vulnerabilities.length;
    const riskScore = totalVulnerabilities > 0 ? 
      Math.min(100, Math.round(
        (severityCounts.critical * 40 + 
         severityCounts.high * 30 + 
         severityCounts.medium * 20 + 
         severityCounts.low * 10) / totalVulnerabilities
      )) : 0;
    
    // Generate overall assessment
    let assessment;
    if (riskScore >= 80) {
      assessment = 'Critical security issues detected. Immediate remediation required.';
    } else if (riskScore >= 60) {
      assessment = 'High security risk. Prompt remediation recommended.';
    } else if (riskScore >= 40) {
      assessment = 'Moderate security risk. Remediation should be planned.';
    } else if (riskScore >= 20) {
      assessment = 'Low security risk. Consider addressing vulnerabilities as part of routine maintenance.';
    } else {
      assessment = 'Minimal security risk detected. Continue with regular security practices.';
    }
    
    return {
      totalVulnerabilities,
      severityCounts,
      typeCounts,
      riskScore,
      assessment
    };
  }
  
  /**
   * Apply self-healing for a vulnerability
   * @param {Object} vulnerability - Vulnerability to remediate
   * @param {string} strategy - Remediation strategy
   * @returns {Promise<Object>} - Remediation result
   */
  async applySelfHealing(vulnerability, strategy) {
    try {
      this.logger.info('Applying self-healing', { 
        vulnerabilityId: vulnerability.id,
        strategy 
      });
      
      // Parse the strategy
      const [action, ...params] = strategy.split(':');
      
      // Apply the appropriate remediation
      switch (action) {
        case 'restrict_port':
          return await this._healRestrictPort(vulnerability, params[0]);
          
        case 'block_ip':
          return await this._healBlockIP(vulnerability, params[0]);
          
        case 'patch_service':
          return await this._healPatchService(vulnerability, params[0]);
          
        default:
          throw new Error(`Unsupported remediation strategy: ${action}`);
      }
    } catch (error) {
      this.logger.error('Self-healing failed', { 
        error: error.message,
        vulnerabilityId: vulnerability.id,
        strategy 
      });
      
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Apply port restriction healing
   * @param {Object} vulnerability - Vulnerability to remediate
   * @param {string} port - Port to restrict
   * @returns {Promise<Object>} - Remediation result
   * @private
   */
  async _healRestrictPort(vulnerability, port) {
    try {
      this.logger.info(`Restricting port ${port}`, { vulnerabilityId: vulnerability.id });
      
      // This would typically involve configuring firewall rules
      // For demonstration, we'll just log the action
      
      // In a real implementation, you would apply actual firewall rules
      // For example, with iptables:
      // const command = `iptables -A INPUT -p tcp --dport ${port} -j DROP`;
      // await exec(command);
      
      this.logger.info(`Port ${port} restriction simulated successfully`);
      
      return {
        success: true,
        action: 'restrict_port',
        port,
        message: `Port ${port} restriction simulated. In production, this would configure firewall rules.`
      };
    } catch (error) {
      throw new Error(`Failed to restrict port: ${error.message}`);
    }
  }
  
  /**
   * Apply IP blocking healing
   * @param {Object} vulnerability - Vulnerability to remediate
   * @param {string} ip - IP to block
   * @returns {Promise<Object>} - Remediation result
   * @private
   */
  async _healBlockIP(vulnerability, ip) {
    try {
      if (ip === 'unknown') {
        throw new Error('Cannot block unknown IP address');
      }
      
      this.logger.info(`Blocking IP ${ip}`, { vulnerabilityId: vulnerability.id });
      
      // This would typically involve configuring firewall rules
      // For demonstration, we'll just log the action
      
      // In a real implementation, you would apply actual firewall rules
      // For example, with iptables:
      // const command = `iptables -A INPUT -s ${ip} -j DROP`;
      // await exec(command);
      
      this.logger.info(`IP ${ip} blocking simulated successfully`);
      
      return {
        success: true,
        action: 'block_ip',
        ip,
        message: `IP ${ip} blocking simulated. In production, this would configure firewall rules.`
      };
    } catch (error) {
      throw new Error(`Failed to block IP: ${error.message}`);
    }
  }
  
  /**
   * Apply service patching healing
   * @param {Object} vulnerability - Vulnerability to remediate
   * @param {string} service - Service to patch
   * @returns {Promise<Object>} - Remediation result
   * @private
   */
  async _healPatchService(vulnerability, service) {
    try {
      this.logger.info(`Patching service ${service}`, { vulnerabilityId: vulnerability.id });
      
      // This would typically involve applying updates or configuration changes
      // For demonstration, we'll just log the action
      
      this.logger.info(`Service ${service} patching simulated successfully`);
      
      return {
        success: true,
        action: 'patch_service',
        service,
        message: `Service ${service} patching simulated. In production, this would apply updates or configuration changes.`
      };
    } catch (error) {
      throw new Error(`Failed to patch service: ${error.message}`);
    }
  }
  
  /**
   * Get Snort status
   * @returns {Object} - Snort status
   */
  getSnortStatus() {
    return {
      isRunning: this.isSnortRunning,
      usingDocker: this.config.useDocker,
      configFile: this.snortConfig.configFile,
      interfaces: this.snortConfig.interfaces
    };
  }
  
  /**
   * Get active scans
   * @returns {Array} - Active scans
   */
  getActiveScans() {
    return Array.from(this.activeScans.entries()).map(([id, scan]) => ({
      id,
      ...scan
    }));
  }
}

module.exports = ScannerManager;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

/**
 * ReportingSystem - Handles security reports and alerts
 * 
 * This class processes security scan results, generates reports,
 * and integrates with the monitoring framework to raise alerts.
 */
class ReportingSystem {
  /**
   * Constructor for ReportingSystem
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Reporting configuration
   * @param {Object} options.monitoring - Monitoring framework interface
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = options.config || {};
    this.monitoring = options.monitoring;
    this.pluginId = options.pluginId;
    this.reportsDir = path.resolve(process.cwd(), 'private/plugins/modules/pentest/reports');
    this.alertThreshold = this.config.alertThreshold || 'medium';
    this.alertThresholdMap = {
      low: 4,
      medium: 3,
      high: 2,
      critical: 1
    };
    this.numericAlertThreshold = this.alertThresholdMap[this.alertThreshold] || 3;
  }
  
  /**
   * Initialize the reporting system
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing ReportingSystem');
      
      // Create reports directory if it doesn't exist
      if (!fs.existsSync(this.reportsDir)) {
        fs.mkdirSync(this.reportsDir, { recursive: true });
        this.logger.info(`Created reports directory: ${this.reportsDir}`);
      }
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize ReportingSystem', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Process scan results and generate a report
   * @param {Object} results - Scan results
   * @param {string} scanType - Type of scan
   * @returns {Promise<Object>} - Processed vulnerabilities
   */
  async processScanResults(results, scanType) {
    try {
      this.logger.info(`Processing ${scanType} scan results`);
      
      // Extract vulnerabilities based on scan type
      let vulnerabilities = [];
      
      if (scanType === 'nmap') {
        vulnerabilities = this._extractVulnerabilitiesFromNmap(results);
      } else if (scanType === 'snort') {
        vulnerabilities = this._extractVulnerabilitiesFromSnort(results);
      } else {
        this.logger.warn(`Unknown scan type: ${scanType}, using generic extraction`);
        vulnerabilities = this._extractGenericVulnerabilities(results);
      }
      
      // Generate a report
      const reportId = crypto.randomBytes(8).toString('hex');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const reportFileName = `${scanType}-report-${timestamp}-${reportId}.json`;
      const reportPath = path.join(this.reportsDir, reportFileName);
      
      // Create report object
      const report = {
        id: reportId,
        scanType,
        timestamp: new Date().toISOString(),
        target: results.target || 'unknown',
        summary: {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter(v => v.severity === 'critical').length,
          high: vulnerabilities.filter(v => v.severity === 'high').length,
          medium: vulnerabilities.filter(v => v.severity === 'medium').length,
          low: vulnerabilities.filter(v => v.severity === 'low').length
        },
        vulnerabilities
      };
      
      // Save the report
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      this.logger.info(`Saved ${scanType} report to ${reportPath}`, {
        reportId,
        vulnerabilitiesCount: vulnerabilities.length
      });
      
      // Raise alerts for high-severity vulnerabilities
      await this._raiseAlertsForVulnerabilities(vulnerabilities, scanType);
      
      return {
        reportId,
        reportPath,
        summary: report.summary,
        items: vulnerabilities
      };
    } catch (error) {
      this.logger.error(`Failed to process ${scanType} scan results`, {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Process pentest results and generate a report
   * @param {Object} results - Pentest results
   * @param {string} testType - Type of test
   * @returns {Promise<Object>} - Processed vulnerabilities
   */
  async processPentestResults(results, testType) {
    try {
      this.logger.info(`Processing ${testType} pentest results`);
      
      // Extract all vulnerabilities from the results
      const vulnerabilities = results.vulnerabilities || [];
      
      // Generate a report
      const reportId = crypto.randomBytes(8).toString('hex');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const reportFileName = `pentest-${testType}-report-${timestamp}-${reportId}.json`;
      const reportPath = path.join(this.reportsDir, reportFileName);
      
      // Create report object
      const report = {
        id: reportId,
        testType,
        timestamp: new Date().toISOString(),
        target: results.target || 'unknown',
        summary: {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter(v => v.severity === 'critical').length,
          high: vulnerabilities.filter(v => v.severity === 'high').length,
          medium: vulnerabilities.filter(v => v.severity === 'medium').length,
          low: vulnerabilities.filter(v => v.severity === 'low').length
        },
        vulnerabilities,
        testResults: results.testResults || {}
      };
      
      // Save the report
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      
      this.logger.info(`Saved ${testType} pentest report to ${reportPath}`, {
        reportId,
        vulnerabilitiesCount: vulnerabilities.length
      });
      
      // Raise alerts for high-severity vulnerabilities
      await this._raiseAlertsForVulnerabilities(vulnerabilities, 'pentest');
      
      return {
        reportId,
        reportPath,
        summary: report.summary,
        items: vulnerabilities
      };
    } catch (error) {
      this.logger.error(`Failed to process ${testType} pentest results`, {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Process an external vulnerability report
   * @param {Object} report - External vulnerability report
   * @returns {Promise<Object>} - Processed report
   */
  async processExternalReport(report) {
    try {
      this.logger.info('Processing external vulnerability report', {
        sourceId: report.sourceId,
        vulnerabilitiesCount: report.vulnerabilities.length
      });
      
      // Validate the report
      if (!report.vulnerabilities || !Array.isArray(report.vulnerabilities)) {
        throw new Error('Invalid report format: vulnerabilities must be an array');
      }
      
      // Generate a report ID and filename
      const reportId = crypto.randomBytes(8).toString('hex');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const reportFileName = `external-report-${timestamp}-${reportId}.json`;
      const reportPath = path.join(this.reportsDir, reportFileName);
      
      // Create report object
      const processedReport = {
        id: reportId,
        sourceId: report.sourceId,
        timestamp: new Date().toISOString(),
        originalTimestamp: report.timestamp,
        summary: {
          total: report.vulnerabilities.length,
          critical: report.vulnerabilities.filter(v => v.severity === 'critical').length,
          high: report.vulnerabilities.filter(v => v.severity === 'high').length,
          medium: report.vulnerabilities.filter(v => v.severity === 'medium').length,
          low: report.vulnerabilities.filter(v => v.severity === 'low').length
        },
        vulnerabilities: report.vulnerabilities
      };
      
      // Save the report
      fs.writeFileSync(reportPath, JSON.stringify(processedReport, null, 2));
      
      this.logger.info(`Saved external report to ${reportPath}`, {
        reportId,
        vulnerabilitiesCount: report.vulnerabilities.length
      });
      
      // Raise alerts for high-severity vulnerabilities
      await this._raiseAlertsForVulnerabilities(report.vulnerabilities, 'external');
      
      return {
        reportId,
        reportPath,
        summary: processedReport.summary
      };
    } catch (error) {
      this.logger.error('Failed to process external report', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Extract vulnerabilities from Nmap results
   * @param {Object} results - Nmap results
   * @returns {Array} - Extracted vulnerabilities
   * @private
   */
  _extractVulnerabilitiesFromNmap(results) {
    // This is a basic implementation for demonstration
    // In a real system, you would have more sophisticated parsing
    const vulnerabilities = [];
    
    try {
      if (results.results && results.results.hosts) {
        for (const host of results.results.hosts) {
          // Skip hosts that are not up
          if (host.state !== 'up') continue;
          
          // Check for open ports
          for (const port of host.ports) {
            if (port.state === 'open') {
              // Generate an ID for the vulnerability
              const id = crypto.createHash('md5')
                .update(`${host.address}:${port.port}:${port.service || 'unknown'}`)
                .digest('hex');
              
              // Determine severity based on the service
              let severity = 'low';
              if (this._isHighRiskService(port.service, port.port)) {
                severity = 'high';
              } else if (this._isMediumRiskService(port.service, port.port)) {
                severity = 'medium';
              }
              
              // Add vulnerability
              vulnerabilities.push({
                id,
                type: 'open_port',
                severity,
                target: host.address,
                description: `Open ${port.service || 'unknown'} service on port ${port.port}`,
                details: {
                  port: port.port,
                  protocol: port.protocol,
                  service: port.service
                },
                remediation: this._getRemediationForPort(port.service, port.port)
              });
            }
          }
        }
      }
    } catch (error) {
      this.logger.error('Error extracting vulnerabilities from Nmap results', {
        error: error.message
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Extract vulnerabilities from Snort results
   * @param {Object} results - Snort results
   * @returns {Array} - Extracted vulnerabilities
   * @private
   */
  _extractVulnerabilitiesFromSnort(results) {
    const vulnerabilities = [];
    
    try {
      if (results.alerts && Array.isArray(results.alerts)) {
        for (const alert of results.alerts) {
          // Generate an ID for the vulnerability
          const id = crypto.createHash('md5')
            .update(`${alert.signatureId || ''}:${alert.signature || ''}:${alert.sourceIp || ''}:${alert.destinationIp || ''}`)
            .digest('hex');
          
          // Determine severity based on Snort priority
          let severity = 'medium';
          if (alert.priority === 1) {
            severity = 'critical';
          } else if (alert.priority === 2) {
            severity = 'high';
          } else if (alert.priority >= 4) {
            severity = 'low';
          }
          
          // Add vulnerability
          vulnerabilities.push({
            id,
            type: 'intrusion_detection',
            severity,
            target: alert.destinationIp || 'unknown',
            description: alert.signature || 'Unknown intrusion attempt',
            details: {
              signatureId: alert.signatureId,
              sourceIp: alert.sourceIp,
              sourcePort: alert.sourcePort,
              destinationIp: alert.destinationIp,
              destinationPort: alert.destinationPort,
              protocol: alert.protocol,
              timestamp: alert.timestamp
            },
            remediation: this._getRemediationForIntrusion(alert)
          });
        }
      }
    } catch (error) {
      this.logger.error('Error extracting vulnerabilities from Snort results', {
        error: error.message
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Extract vulnerabilities from generic results
   * @param {Object} results - Generic results
   * @returns {Array} - Extracted vulnerabilities
   * @private
   */
  _extractGenericVulnerabilities(results) {
    // This is a basic implementation for demonstration
    // In a real system, you would have more sophisticated parsing
    const vulnerabilities = [];
    
    try {
      // If the results already have a vulnerabilities array, use that
      if (results.vulnerabilities && Array.isArray(results.vulnerabilities)) {
        return results.vulnerabilities;
      }
      
      // Otherwise, try to extract from raw results
      if (results.raw) {
        // Look for common vulnerability patterns in stdout
        if (results.raw.stdout) {
          // Split by lines
          const lines = results.raw.stdout.split('\n');
          
          for (const line of lines) {
            // Look for patterns that might indicate vulnerabilities
            if (line.match(/vulnerability|warning|critical|high|medium|CVE-\d{4}-\d+/i)) {
              // Generate an ID for the vulnerability
              const id = crypto.createHash('md5')
                .update(line)
                .digest('hex');
              
              // Determine severity based on content
              let severity = 'medium';
              if (line.match(/critical|high risk|severe/i)) {
                severity = 'high';
              } else if (line.match(/medium|moderate/i)) {
                severity = 'medium';
              } else if (line.match(/low|info/i)) {
                severity = 'low';
              }
              
              // Add vulnerability
              vulnerabilities.push({
                id,
                type: 'generic',
                severity,
                target: results.target || 'unknown',
                description: line.trim(),
                details: {
                  rawOutput: line
                },
                remediation: 'Investigate and address the identified issue.'
              });
            }
          }
        }
      }
    } catch (error) {
      this.logger.error('Error extracting generic vulnerabilities', {
        error: error.message
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Check if a service is high risk
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {boolean} - True if the service is high risk
   * @private
   */
  _isHighRiskService(service, port) {
    const highRiskServices = [
      'ftp', 'telnet', 'rsh', 'rlogin',
      'ms-sql', 'mysql', 'mongodb', 'redis',
      'smb', 'netbios',
      'vnc', 'rdp'
    ];
    
    const highRiskPorts = [
      21, 23, 3389, 445, 1433, 3306, 6379, 5900
    ];
    
    return highRiskServices.includes(service) || highRiskPorts.includes(port);
  }
  
  /**
   * Check if a service is medium risk
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {boolean} - True if the service is medium risk
   * @private
   */
  _isMediumRiskService(service, port) {
    const mediumRiskServices = [
      'http', 'https', 'ssh', 'smtp', 'pop3', 'imap',
      'dns', 'nfs', 'snmp'
    ];
    
    const mediumRiskPorts = [
      22, 25, 80, 443, 110, 143, 53, 161
    ];
    
    return mediumRiskServices.includes(service) || mediumRiskPorts.includes(port);
  }
  
  /**
   * Get remediation recommendation for a port
   * @param {string} service - Service name
   * @param {number} port - Port number
   * @returns {string} - Remediation recommendation
   * @private
   */
  _getRemediationForPort(service, port) {
    // Default remediation
    let remediation = `Consider whether port ${port} needs to be exposed. If not, close it or restrict access using firewall rules.`;
    
    // Service-specific remediations
    switch (service) {
      case 'ftp':
        remediation = `FTP on port ${port} transmits data in cleartext. Consider replacing with SFTP or FTPS, or restrict access to trusted IPs only.`;
        break;
      case 'telnet':
        remediation = `Telnet on port ${port} is insecure and transmits data in cleartext. Replace with SSH for secure remote access.`;
        break;
      case 'http':
        remediation = `Ensure the web server on port ${port} is properly secured with the latest updates and security configurations.`;
        break;
      case 'https':
        remediation = `Ensure the web server on port ${port} uses strong TLS configurations and has the latest security updates.`;
        break;
      case 'ssh':
        remediation = `Ensure SSH on port ${port} is configured securely: disable root login, use key-based authentication, and limit user access.`;
        break;
      case 'mysql':
      case 'ms-sql':
      case 'mongodb':
      case 'redis':
        remediation = `Database service on port ${port} should not be directly exposed to the internet. Use a firewall to restrict access to trusted IPs only.`;
        break;
      case 'smb':
      case 'netbios':
        remediation = `Windows file sharing services on port ${port} should not be exposed to the internet. Restrict access using firewall rules.`;
        break;
      case 'rdp':
      case 'vnc':
        remediation = `Remote desktop service on port ${port} should be secured with strong authentication and restricted to trusted IPs.`;
        break;
    }
    
    return remediation;
  }
  
  /**
   * Get remediation recommendation for an intrusion
   * @param {Object} alert - Snort alert
   * @returns {string} - Remediation recommendation
   * @private
   */
  _getRemediationForIntrusion(alert) {
    // Default remediation
    let remediation = `Investigate the traffic between ${alert.sourceIp || 'unknown'} and ${alert.destinationIp || 'unknown'}.`;
    
    // Add more specific recommendations based on the alert signature
    if (alert.signature) {
      const signature = alert.signature.toLowerCase();
      
      if (signature.includes('scan') || signature.includes('reconnaissance')) {
        remediation += ' This appears to be a reconnaissance attempt. Consider blocking the source IP if it\'s not a legitimate source.';
      } else if (signature.includes('exploit') || signature.includes('overflow') || signature.includes('injection')) {
        remediation += ' This appears to be an exploit attempt. Ensure the target system is patched and consider blocking the source IP.';
      } else if (signature.includes('dos') || signature.includes('denial of service')) {
        remediation += ' This appears to be a denial of service attempt. Consider implementing rate limiting and blocking the source IP.';
      } else if (signature.includes('malware') || signature.includes('trojan') || signature.includes('virus')) {
        remediation += ' This appears to be malware-related traffic. Scan the target system for malware and consider blocking the source IP.';
      }
    }
    
    return remediation;
  }
  
  /**
   * Raise alerts for high-severity vulnerabilities
   * @param {Array} vulnerabilities - List of vulnerabilities
   * @param {string} source - Source of the vulnerabilities
   * @returns {Promise<void>}
   * @private
   */
  async _raiseAlertsForVulnerabilities(vulnerabilities, source) {
    try {
      if (!this.monitoring) {
        this.logger.debug('Monitoring framework not available, skipping alerts');
        return;
      }
      
      // Filter vulnerabilities that meet the alert threshold
      const alertableVulnerabilities = vulnerabilities.filter(vuln => {
        const severityLevel = this._getSeverityLevel(vuln.severity);
        return severityLevel <= this.numericAlertThreshold;
      });
      
      if (alertableVulnerabilities.length === 0) {
        this.logger.debug('No vulnerabilities meet the alert threshold');
        return;
      }
      
      // Group vulnerabilities by severity
      const groupedVulnerabilities = alertableVulnerabilities.reduce((acc, vuln) => {
        acc[vuln.severity] = acc[vuln.severity] || [];
        acc[vuln.severity].push(vuln);
        return acc;
      }, {});
      
      // Raise alerts for each severity group
      for (const [severity, vulns] of Object.entries(groupedVulnerabilities)) {
        if (vulns.length > 0) {
          const alertTitle = `${severity.charAt(0).toUpperCase() + severity.slice(1)} severity ${source} vulnerabilities detected`;
          const alertDescription = `${vulns.length} ${severity} severity vulnerabilities detected from ${source}.`;
          
          // Create alert details
          const alertDetails = {
            source,
            severity,
            count: vulns.length,
            vulnerabilities: vulns.map(v => ({
              id: v.id,
              type: v.type,
              description: v.description,
              target: v.target
            }))
          };
          
          // Raise alert through monitoring framework
          await this.monitoring.reportAlert(
            'pentest_vulnerability_detected',
            alertTitle,
            alertDescription,
            alertDetails,
            severity
          );
          
          this.logger.info(`Raised ${severity} severity alert for ${vulns.length} vulnerabilities`);
        }
      }
    } catch (error) {
      this.logger.error('Error raising alerts for vulnerabilities', {
        error: error.message
      });
    }
  }
  
  /**
   * Get numeric severity level
   * @param {string} severity - Severity string
   * @returns {number} - Numeric severity level (lower is more severe)
   * @private
   */
  _getSeverityLevel(severity) {
    return this.alertThresholdMap[severity.toLowerCase()] || 5;
  }
  
  /**
   * Get the most recent reports
   * @param {number} limit - Maximum number of reports to return
   * @returns {Array} - Recent reports
   */
  getRecentReports(limit = 10) {
    try {
      // Get all report files
      const files = fs.readdirSync(this.reportsDir)
        .filter(file => file.endsWith('.json'))
        .map(file => {
          const filePath = path.join(this.reportsDir, file);
          const stats = fs.statSync(filePath);
          return {
            name: file,
            path: filePath,
            mtime: stats.mtime
          };
        });
      
      // Sort by modification time (newest first)
      files.sort((a, b) => b.mtime - a.mtime);
      
      // Take the requested number of reports
      const recentFiles = files.slice(0, limit);
      
      // Load and parse each report
      return recentFiles.map(file => {
        try {
          const reportContent = fs.readFileSync(file.path, 'utf8');
          const report = JSON.parse(reportContent);
          
          // Add file info
          report.fileName = file.name;
          report.filePath = file.path;
          report.fileTimestamp = file.mtime;
          
          return report;
        } catch (parseError) {
          this.logger.error(`Error parsing report file: ${file.name}`, {
            error: parseError.message
          });
          
          return {
            error: 'Failed to parse report',
            fileName: file.name,
            filePath: file.path,
            fileTimestamp: file.mtime
          };
        }
      });
    } catch (error) {
      this.logger.error('Error getting recent reports', {
        error: error.message
      });
      return [];
    }
  }
  
  /**
   * Get a specific report by ID
   * @param {string} reportId - Report ID
   * @returns {Object|null} - Report or null if not found
   */
  getReportById(reportId) {
    try {
      // Get all report files
      const files = fs.readdirSync(this.reportsDir)
        .filter(file => file.endsWith('.json'));
      
      // Find the file containing the report ID
      for (const file of files) {
        const filePath = path.join(this.reportsDir, file);
        try {
          const reportContent = fs.readFileSync(filePath, 'utf8');
          const report = JSON.parse(reportContent);
          
          if (report.id === reportId) {
            // Add file info
            report.fileName = file;
            report.filePath = filePath;
            report.fileTimestamp = fs.statSync(filePath).mtime;
            
            return report;
          }
        } catch (parseError) {
          this.logger.debug(`Error parsing report file: ${file}`, {
            error: parseError.message
          });
        }
      }
      
      return null;
    } catch (error) {
      this.logger.error('Error getting report by ID', {
        error: error.message,
        reportId
      });
      return null;
    }
  }
  
  /**
   * Delete old reports
   * @param {number} olderThanDays - Delete reports older than this many days
   * @returns {number} - Number of deleted reports
   */
  cleanupOldReports(olderThanDays = 30) {
    try {
      const cutoffTime = new Date();
      cutoffTime.setDate(cutoffTime.getDate() - olderThanDays);
      
      // Get all report files
      const files = fs.readdirSync(this.reportsDir)
        .filter(file => file.endsWith('.json'))
        .map(file => {
          const filePath = path.join(this.reportsDir, file);
          const stats = fs.statSync(filePath);
          return {
            name: file,
            path: filePath,
            mtime: stats.mtime
          };
        });
      
      // Filter files older than the cutoff
      const oldFiles = files.filter(file => file.mtime < cutoffTime);
      
      // Delete old files
      let deletedCount = 0;
      for (const file of oldFiles) {
        fs.unlinkSync(file.path);
        deletedCount++;
      }
      
      this.logger.info(`Deleted ${deletedCount} old reports older than ${olderThanDays} days`);
      
      return deletedCount;
    } catch (error) {
      this.logger.error('Error cleaning up old reports', {
        error: error.message
      });
      return 0;
    }
  }
}

module.exports = ReportingSystem;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const EventEmitter = require('events');
const cron = require('node-cron');
const crypto = require('crypto');

/**
 * PentestScheduler - Manages scheduled security testing tasks
 * 
 * This class handles scheduling and execution of security scans and tests
 * based on cron-like expressions and intervals.
 */
class PentestScheduler extends EventEmitter {
  /**
   * Constructor for PentestScheduler
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Scheduler configuration
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    super();
    this.logger = options.logger;
    this.config = options.config || {};
    this.pluginId = options.pluginId;
    this.defaultScanInterval = this.config.defaultScanInterval || 3600000; // 1 hour in ms
    this.pentestSchedule = this.config.pentestSchedule || '0 0 * * 1'; // Weekly on Monday
    this.pressureTestSchedule = this.config.pressureTestSchedule || '0 0 1 * *'; // Monthly on the 1st
    this.scheduledTasks = new Map();
    this.isRunning = false;
  }
  
  /**
   * Initialize the scheduler
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing PentestScheduler');
      
      // Set up scheduled tasks based on configuration
      this._setupDefaultScheduledTasks();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize PentestScheduler', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Set up default scheduled tasks
   * @private
   */
  _setupDefaultScheduledTasks() {
    try {
      // Setup Nmap scheduled scans if configured
      if (this.config.scanners && this.config.scanners.nmap && this.config.scanners.nmap.scheduledScans) {
        const nmapConfig = this.config.scanners.nmap;
        
        for (const [scanName, scanConfig] of Object.entries(nmapConfig.scheduledScans)) {
          if (scanConfig.cronSchedule && scanConfig.enabled !== false) {
            this.scheduleTask({
              name: `nmap-${scanName}`,
              cronSchedule: scanConfig.cronSchedule,
              taskType: 'scan',
              scanType: 'nmap',
              scanOptions: scanConfig.options,
              target: scanConfig.targets || 'local',
              priority: scanConfig.priority || 'normal'
            });
            
            this.logger.info(`Scheduled Nmap scan: ${scanName}`, {
              cronSchedule: scanConfig.cronSchedule
            });
          }
        }
      }
      
      // Setup Snort log check if configured
      if (this.config.scanners && this.config.scanners.snort && this.config.scanners.snort.enabled) {
        const snortConfig = this.config.scanners.snort;
        
        if (snortConfig.logCheckSchedule) {
          this.scheduleTask({
            name: 'snort-log-check',
            cronSchedule: snortConfig.logCheckSchedule,
            taskType: 'scan',
            scanType: 'snort',
            priority: 'normal'
          });
          
          this.logger.info('Scheduled Snort log check', {
            cronSchedule: snortConfig.logCheckSchedule
          });
        }
      }
      
      // Setup comprehensive pentest if configured
      if (this.pentestSchedule) {
        this.scheduleTask({
          name: 'comprehensive-pentest',
          cronSchedule: this.pentestSchedule,
          taskType: 'pentest',
          testType: 'comprehensive',
          target: 'local',
          priority: 'high'
        });
        
        this.logger.info('Scheduled comprehensive penetration test', {
          cronSchedule: this.pentestSchedule
        });
      }
      
      // Setup pressure test if configured
      if (this.pressureTestSchedule) {
        this.scheduleTask({
          name: 'pressure-test',
          cronSchedule: this.pressureTestSchedule,
          taskType: 'pentest',
          testType: 'pressureTest',
          target: 'local',
          priority: 'high'
        });
        
        this.logger.info('Scheduled pressure test', {
          cronSchedule: this.pressureTestSchedule
        });
      }
    } catch (error) {
      this.logger.error('Error setting up default scheduled tasks', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Schedule a task
   * @param {Object} taskConfig - Task configuration
   * @returns {string} - Task ID
   */
  scheduleTask(taskConfig) {
    try {
      const taskId = taskConfig.id || `${taskConfig.name}-${crypto.randomBytes(4).toString('hex')}`;
      
      // Check if the task already exists
      if (this.scheduledTasks.has(taskId)) {
        // Stop the existing task
        const existingTask = this.scheduledTasks.get(taskId);
        if (existingTask.cronJob) {
          existingTask.cronJob.stop();
        }
        if (existingTask.timer) {
          clearTimeout(existingTask.timer);
        }
      }
      
      // Create the task
      const task = {
        id: taskId,
        config: { ...taskConfig },
        status: 'scheduled',
        nextRunTime: null,
        lastRunTime: null
      };
      
      // Schedule based on type
      if (taskConfig.cronSchedule) {
        // Cron-based scheduling
        if (!cron.validate(taskConfig.cronSchedule)) {
          throw new Error(`Invalid cron schedule: ${taskConfig.cronSchedule}`);
        }
        
        task.cronJob = cron.schedule(taskConfig.cronSchedule, () => {
          this._runTask(taskId);
        }, {
          scheduled: this.isRunning
        });
        
        // Calculate next run time
        if (this.isRunning) {
          task.nextRunTime = cron.nextDate(taskConfig.cronSchedule);
          this.logger.debug(`Next run time for task ${taskId}: ${task.nextRunTime}`);
        }
      } else if (taskConfig.interval) {
        // Interval-based scheduling (in milliseconds)
        const interval = taskConfig.interval;
        
        const scheduleNextRun = () => {
          task.timer = setTimeout(() => {
            this._runTask(taskId).finally(() => {
              if (this.isRunning && this.scheduledTasks.has(taskId)) {
                scheduleNextRun();
              }
            });
          }, interval);
          
          task.nextRunTime = new Date(Date.now() + interval);
          this.logger.debug(`Next run time for task ${taskId}: ${task.nextRunTime}`);
        };
        
        if (this.isRunning) {
          scheduleNextRun();
        }
      } else {
        // One-time task scheduled for immediate execution when started
        task.isOneTime = true;
      }
      
      // Store the task
      this.scheduledTasks.set(taskId, task);
      
      this.logger.info(`Scheduled task: ${taskConfig.name}`, {
        taskId,
        taskType: taskConfig.taskType,
        cronSchedule: taskConfig.cronSchedule,
        interval: taskConfig.interval
      });
      
      return taskId;
    } catch (error) {
      this.logger.error('Error scheduling task', {
        error: error.message,
        taskConfig
      });
      throw error;
    }
  }
  
  /**
   * Run a scheduled task
   * @param {string} taskId - Task ID
   * @returns {Promise<void>}
   * @private
   */
  async _runTask(taskId) {
    try {
      const task = this.scheduledTasks.get(taskId);
      
      if (!task) {
        this.logger.warn(`Task not found: ${taskId}`);
        return;
      }
      
      this.logger.info(`Running scheduled task: ${task.config.name}`, { taskId });
      
      // Update task status
      task.status = 'running';
      task.lastRunTime = new Date();
      
      // Run the task based on type
      if (task.config.taskType === 'scan') {
        // Emit scan event
        this.emit('scheduled-scan', {
          ...task.config,
          taskId,
          timestamp: new Date()
        });
      } else if (task.config.taskType === 'pentest') {
        // Emit pentest event
        this.emit('scheduled-pentest', {
          ...task.config,
          taskId,
          timestamp: new Date()
        });
      } else {
        this.logger.warn(`Unknown task type: ${task.config.taskType}`);
      }
      
      // Update task status
      task.status = 'completed';
      
      // Remove one-time tasks
      if (task.isOneTime) {
        this.scheduledTasks.delete(taskId);
      }
    } catch (error) {
      this.logger.error(`Error running task ${taskId}`, {
        error: error.message
      });
      
      // Update task status
      const task = this.scheduledTasks.get(taskId);
      if (task) {
        task.status = 'failed';
        task.lastError = error.message;
      }
    }
  }
  
  /**
   * Start the scheduler
   * @returns {Promise<boolean>} - True if start was successful
   */
  async start() {
    try {
      if (this.isRunning) {
        this.logger.info('Scheduler is already running');
        return true;
      }
      
      this.logger.info('Starting PentestScheduler');
      
      // Start all cron jobs
      for (const [taskId, task] of this.scheduledTasks.entries()) {
        if (task.cronJob) {
          task.cronJob.start();
          task.nextRunTime = cron.nextDate(task.config.cronSchedule);
          this.logger.debug(`Next run time for task ${taskId}: ${task.nextRunTime}`);
        } else if (task.config.interval) {
          // Schedule interval-based task
          const scheduleNextRun = () => {
            task.timer = setTimeout(() => {
              this._runTask(taskId).finally(() => {
                if (this.isRunning && this.scheduledTasks.has(taskId)) {
                  scheduleNextRun();
                }
              });
            }, task.config.interval);
            
            task.nextRunTime = new Date(Date.now() + task.config.interval);
            this.logger.debug(`Next run time for task ${taskId}: ${task.nextRunTime}`);
          };
          
          scheduleNextRun();
        } else if (task.isOneTime) {
          // Run one-time tasks immediately
          this._runTask(taskId);
        }
      }
      
      this.isRunning = true;
      this.logger.info('PentestScheduler started successfully');
      
      return true;
    } catch (error) {
      this.logger.error('Failed to start PentestScheduler', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Stop the scheduler
   * @returns {Promise<boolean>} - True if stop was successful
   */
  async stop() {
    try {
      if (!this.isRunning) {
        this.logger.info('Scheduler is not running');
        return true;
      }
      
      this.logger.info('Stopping PentestScheduler');
      
      // Stop all cron jobs
      for (const [taskId, task] of this.scheduledTasks.entries()) {
        if (task.cronJob) {
          task.cronJob.stop();
        }
        if (task.timer) {
          clearTimeout(task.timer);
          task.timer = null;
        }
        
        task.nextRunTime = null;
      }
      
      this.isRunning = false;
      this.logger.info('PentestScheduler stopped successfully');
      
      return true;
    } catch (error) {
      this.logger.error('Failed to stop PentestScheduler', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Get scheduled tasks
   * @returns {Array} - List of scheduled tasks
   */
  getScheduledTasks() {
    return Array.from(this.scheduledTasks.entries()).map(([id, task]) => ({
      id,
      name: task.config.name,
      type: task.config.taskType,
      status: task.status,
      cronSchedule: task.config.cronSchedule,
      interval: task.config.interval,
      nextRunTime: task.nextRunTime,
      lastRunTime: task.lastRunTime,
      lastError: task.lastError
    }));
  }
  
  /**
   * Run a task immediately
   * @param {string} taskId - Task ID
   * @returns {Promise<boolean>} - True if the task was run successfully
   */
  async runTaskNow(taskId) {
    try {
      if (!this.scheduledTasks.has(taskId)) {
        throw new Error(`Task not found: ${taskId}`);
      }
      
      await this._runTask(taskId);
      return true;
    } catch (error) {
      this.logger.error(`Failed to run task ${taskId}`, {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Delete a scheduled task
   * @param {string} taskId - Task ID
   * @returns {boolean} - True if the task was deleted
   */
  deleteTask(taskId) {
    try {
      if (!this.scheduledTasks.has(taskId)) {
        return false;
      }
      
      const task = this.scheduledTasks.get(taskId);
      
      // Stop the task
      if (task.cronJob) {
        task.cronJob.stop();
      }
      if (task.timer) {
        clearTimeout(task.timer);
      }
      
      // Remove the task
      this.scheduledTasks.delete(taskId);
      
      this.logger.info(`Deleted scheduled task: ${task.config.name}`, { taskId });
      
      return true;
    } catch (error) {
      this.logger.error(`Failed to delete task ${taskId}`, {
        error: error.message
      });
      return false;
    }
  }
}

module.exports = PentestScheduler;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const EventEmitter = require('events');
const crypto = require('crypto');
const { v4: uuidv4 } = require('uuid');

/**
 * PentestCommunicator - Handles communication between cores for security testing
 * 
 * This class enables secure communication between different cores/nodes in the
 * distributed system, allowing for coordinated security testing.
 */
class PentestCommunicator extends EventEmitter {
  /**
   * Constructor for PentestCommunicator
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Communication configuration
   * @param {Object} options.messageBus - Message bus for communication
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    super();
    this.logger = options.logger;
    this.config = options.config || {};
    this.messageBus = options.messageBus;
    this.pluginId = options.pluginId;
    this.coreId = options.coreId || `core-${crypto.randomBytes(4).toString('hex')}`;
    this.pendingRequests = new Map();
    this.encryptionEnabled = this.config.encryptionEnabled !== false;
    this.authRequired = this.config.authRequired !== false;
    this.requestTimeout = this.config.requestTimeout || 30000; // 30 seconds
    
    // Generate or use provided encryption key
    if (this.encryptionEnabled) {
      this.encryptionKey = this.config.encryptionKey || crypto.randomBytes(32).toString('hex');
    }
  }
  
  /**
   * Initialize the communicator
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing PentestCommunicator');
      
      if (!this.messageBus) {
        throw new Error('Message bus is required for PentestCommunicator');
      }
      
      // Subscribe to pentest-related topics
      await this._subscribeToTopics();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize PentestCommunicator', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Subscribe to communication topics
   * @private
   */
  async _subscribeToTopics() {
    try {
      // Subscribe to pentest request topic
      await this.messageBus.subscribe('pentest.request', this._handlePentestRequest.bind(this));
      
      // Subscribe to pentest response topic
      await this.messageBus.subscribe('pentest.response', this._handlePentestResponse.bind(this));
      
      // Subscribe to vulnerability report topic
      await this.messageBus.subscribe('pentest.vulnerability_report', this._handleVulnerabilityReport.bind(this));
      
      this.logger.info('Subscribed to pentest communication topics');
    } catch (error) {
      throw new Error(`Failed to subscribe to topics: ${error.message}`);
    }
  }
  
  /**
   * Handle incoming pentest request
   * @param {Object} message - Pentest request message
   * @private
   */
  _handlePentestRequest(message) {
    try {
      this.logger.debug('Received pentest request', { message });
      
      // Decrypt message if encryption is enabled
      let request = message;
      if (this.encryptionEnabled && message.encrypted) {
        request = this._decryptMessage(message);
      }
      
      // Validate the request
      if (!this.validateRequest(request)) {
        this.logger.warn('Invalid pentest request', { request });
        return;
      }
      
      // Emit pentest request event
      this.emit('pentest-request', request);
    } catch (error) {
      this.logger.error('Error handling pentest request', {
        error: error.message,
        message
      });
    }
  }
  
  /**
   * Handle incoming pentest response
   * @param {Object} message - Pentest response message
   * @private
   */
  _handlePentestResponse(message) {
    try {
      this.logger.debug('Received pentest response', { message });
      
      // Decrypt message if encryption is enabled
      let response = message;
      if (this.encryptionEnabled && message.encrypted) {
        response = this._decryptMessage(message);
      }
      
      // Validate the response
      if (!this._validateResponse(response)) {
        this.logger.warn('Invalid pentest response', { response });
        return;
      }
      
      // Check if this is a response to a pending request
      const requestId = response.requestId;
      if (this.pendingRequests.has(requestId)) {
        const pendingRequest = this.pendingRequests.get(requestId);
        
        // Clear timeout
        if (pendingRequest.timeoutId) {
          clearTimeout(pendingRequest.timeoutId);
        }
        
        // Resolve or reject the promise
        if (response.success) {
          pendingRequest.resolve(response);
        } else {
          pendingRequest.reject(new Error(response.error || 'Request failed'));
        }
        
        // Remove from pending requests
        this.pendingRequests.delete(requestId);
      }
      
      // Emit pentest response event
      this.emit('pentest-response', response);
    } catch (error) {
      this.logger.error('Error handling pentest response', {
        error: error.message,
        message
      });
    }
  }
  
  /**
   * Handle incoming vulnerability report
   * @param {Object} message - Vulnerability report message
   * @private
   */
  _handleVulnerabilityReport(message) {
    try {
      this.logger.debug('Received vulnerability report', { message });
      
      // Decrypt message if encryption is enabled
      let report = message;
      if (this.encryptionEnabled && message.encrypted) {
        report = this._decryptMessage(message);
      }
      
      // Validate the report
      if (!this.validateReport(report)) {
        this.logger.warn('Invalid vulnerability report', { report });
        return;
      }
      
      // Emit vulnerability report event
      this.emit('vulnerability-report', report);
    } catch (error) {
      this.logger.error('Error handling vulnerability report', {
        error: error.message,
        message
      });
    }
  }
  
  /**
   * Request a distributed pentest
   * @param {Object} pentestConfig - Pentest configuration
   * @returns {Promise<Object>} - Response from other cores
   */
  async requestDistributedPentest(pentestConfig) {
    try {
      this.logger.info('Requesting distributed pentest', { pentestConfig });
      
      // Create request ID
      const requestId = uuidv4();
      
      // Create request message
      const request = {
        requestId,
        sourceId: this.coreId,
        timestamp: new Date().toISOString(),
        testType: pentestConfig.testType || 'comprehensive',
        options: pentestConfig.options || {},
        priority: pentestConfig.priority || 'high',
        scope: pentestConfig.scope || 'distributed',
        targetIds: pentestConfig.targetIds || [] // Empty array means all cores
      };
      
      // Prepare message for sending
      let message = request;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        message = this._encryptMessage(request);
      }
      
      // Create a promise for the response
      const responsePromise = new Promise((resolve, reject) => {
        // Create pending request entry
        this.pendingRequests.set(requestId, {
          request,
          timestamp: Date.now(),
          resolve,
          reject,
          timeoutId: setTimeout(() => {
            // Handle timeout
            if (this.pendingRequests.has(requestId)) {
              const pendingRequest = this.pendingRequests.get(requestId);
              pendingRequest.reject(new Error('Request timed out'));
              this.pendingRequests.delete(requestId);
            }
          }, this.requestTimeout)
        });
        
        // Publish the request
        this.messageBus.publish('pentest.request', message)
          .catch(error => {
            this.logger.error('Error publishing pentest request', {
              error: error.message,
              requestId
            });
            
            reject(error);
          });
      });
      
      return responsePromise;
    } catch (error) {
      this.logger.error('Error requesting distributed pentest', {
        error: error.message,
        pentestConfig
      });
      throw error;
    }
  }
  
  /**
   * Acknowledge a pentest request
   * @param {Object} request - Pentest request to acknowledge
   * @returns {Promise<boolean>} - True if acknowledgment was successful
   */
  async acknowledgePentestRequest(request) {
    try {
      this.logger.info('Acknowledging pentest request', {
        requestId: request.requestId,
        sourceId: request.sourceId
      });
      
      // Create acknowledgment message
      const response = {
        requestId: request.requestId,
        sourceId: this.coreId,
        targetId: request.sourceId,
        timestamp: new Date().toISOString(),
        type: 'acknowledgment',
        success: true
      };
      
      // Prepare message for sending
      let message = response;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        message = this._encryptMessage(response);
      }
      
      // Publish the response
      await this.messageBus.publish('pentest.response', message);
      
      return true;
    } catch (error) {
      this.logger.error('Error acknowledging pentest request', {
        error: error.message,
        requestId: request.requestId
      });
      throw error;
    }
  }
  
  /**
   * Reject a pentest request
   * @param {Object} request - Pentest request to reject
   * @param {string} reason - Reason for rejection
   * @returns {Promise<boolean>} - True if rejection was successful
   */
  async rejectPentestRequest(request, reason) {
    try {
      this.logger.info('Rejecting pentest request', {
        requestId: request.requestId,
        sourceId: request.sourceId,
        reason
      });
      
      // Create rejection message
      const response = {
        requestId: request.requestId,
        sourceId: this.coreId,
        targetId: request.sourceId,
        timestamp: new Date().toISOString(),
        type: 'rejection',
        success: false,
        error: reason
      };
      
      // Prepare message for sending
      let message = response;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        message = this._encryptMessage(response);
      }
      
      // Publish the response
      await this.messageBus.publish('pentest.response', message);
      
      return true;
    } catch (error) {
      this.logger.error('Error rejecting pentest request', {
        error: error.message,
        requestId: request.requestId
      });
      throw error;
    }
  }
  
  /**
   * Send a vulnerability report to another core
   * @param {Object} report - Vulnerability report
   * @returns {Promise<boolean>} - True if report was sent successfully
   */
  async sendVulnerabilityReport(report) {
    try {
      this.logger.info('Sending vulnerability report', {
        targetId: report.sourceId,
        vulnerabilitiesCount: report.vulnerabilities.length
      });
      
      // Create report message
      const message = {
        requestId: report.requestId,
        sourceId: this.coreId,
        targetId: report.sourceId,
        timestamp: new Date().toISOString(),
        vulnerabilities: report.vulnerabilities,
        summary: report.summary
      };
      
      // Prepare message for sending
      let preparedMessage = message;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        preparedMessage = this._encryptMessage(message);
      }
      
      // Publish the report
      await this.messageBus.publish('pentest.vulnerability_report', preparedMessage);
      
      return true;
    } catch (error) {
      this.logger.error('Error sending vulnerability report', {
        error: error.message,
        targetId: report.sourceId
      });
      throw error;
    }
  }
  
  /**
   * Send a pentest failure notification
   * @param {Object} failure - Failure details
   * @returns {Promise<boolean>} - True if notification was sent successfully
   */
  async sendPentestFailure(failure) {
    try {
      this.logger.info('Sending pentest failure notification', {
        requestId: failure.requestId,
        targetId: failure.sourceId,
        error: failure.error
      });
      
      // Create failure message
      const response = {
        requestId: failure.requestId,
        sourceId: this.coreId,
        targetId: failure.sourceId,
        timestamp: new Date().toISOString(),
        type: 'failure',
        success: false,
        error: failure.error
      };
      
      // Prepare message for sending
      let message = response;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        message = this._encryptMessage(response);
      }
      
      // Publish the response
      await this.messageBus.publish('pentest.response', message);
      
      return true;
    } catch (error) {
      this.logger.error('Error sending pentest failure notification', {
        error: error.message,
        requestId: failure.requestId
      });
      throw error;
    }
  }
  
  /**
   * Acknowledge a vulnerability report
   * @param {Object} report - Vulnerability report to acknowledge
   * @returns {Promise<boolean>} - True if acknowledgment was successful
   */
  async acknowledgeVulnerabilityReport(report) {
    try {
      this.logger.info('Acknowledging vulnerability report', {
        sourceId: report.sourceId
      });
      
      // Create acknowledgment message
      const response = {
        requestId: report.requestId,
        sourceId: this.coreId,
        targetId: report.sourceId,
        timestamp: new Date().toISOString(),
        type: 'report_acknowledgment',
        success: true
      };
      
      // Prepare message for sending
      let message = response;
      
      // Encrypt message if encryption is enabled
      if (this.encryptionEnabled) {
        message = this._encryptMessage(response);
      }
      
      // Publish the response
      await this.messageBus.publish('pentest.response', message);
      
      return true;
    } catch (error) {
      this.logger.error('Error acknowledging vulnerability report', {
        error: error.message,
        sourceId: report.sourceId
      });
      throw error;
    }
  }
  
  /**
   * Validate a pentest request
   * @param {Object} request - Pentest request to validate
   * @returns {boolean} - True if request is valid
   */
  validateRequest(request) {
    // Basic validation
    if (!request || typeof request !== 'object') {
      return false;
    }
    
    // Required fields
    if (!request.requestId || !request.sourceId || !request.timestamp) {
      return false;
    }
    
    // Timestamp validation
    const requestTime = new Date(request.timestamp);
    if (isNaN(requestTime.getTime())) {
      return false;
    }
    
    // Check for request freshness (within last 5 minutes)
    const now = new Date();
    const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
    if (requestTime < fiveMinutesAgo) {
      this.logger.warn('Request is too old', {
        requestTime,
        now
      });
      return false;
    }
    
    // Authentication check if required
    if (this.authRequired && !this._verifyAuthentication(request)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validate a response message
   * @param {Object} response - Response to validate
   * @returns {boolean} - True if response is valid
   * @private
   */
  _validateResponse(response) {
    // Basic validation
    if (!response || typeof response !== 'object') {
      return false;
    }
    
    // Required fields
    if (!response.requestId || !response.sourceId || !response.timestamp) {
      return false;
    }
    
    // Timestamp validation
    const responseTime = new Date(response.timestamp);
    if (isNaN(responseTime.getTime())) {
      return false;
    }
    
    // Check for response freshness (within last 5 minutes)
    const now = new Date();
    const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
    if (responseTime < fiveMinutesAgo) {
      this.logger.warn('Response is too old', {
        responseTime,
        now
      });
      return false;
    }
    
    // Authentication check if required
    if (this.authRequired && !this._verifyAuthentication(response)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validate a vulnerability report
   * @param {Object} report - Vulnerability report to validate
   * @returns {boolean} - True if report is valid
   */
  validateReport(report) {
    // Basic validation
    if (!report || typeof report !== 'object') {
      return false;
    }
    
    // Required fields
    if (!report.sourceId || !report.timestamp || !report.vulnerabilities) {
      return false;
    }
    
    // Vulnerabilities must be an array
    if (!Array.isArray(report.vulnerabilities)) {
      return false;
    }
    
    // Timestamp validation
    const reportTime = new Date(report.timestamp);
    if (isNaN(reportTime.getTime())) {
      return false;
    }
    
    // Check for report freshness (within last hour)
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    if (reportTime < oneHourAgo) {
      this.logger.warn('Report is too old', {
        reportTime,
        now
      });
      return false;
    }
    
    // Authentication check if required
    if (this.authRequired && !this._verifyAuthentication(report)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Verify authentication of a message
   * @param {Object} message - Message to verify
   * @returns {boolean} - True if authentication is valid
   * @private
   */
  _verifyAuthentication(message) {
    // In a real implementation, this would verify signatures, tokens, etc.
    // For this example, we'll just check if the message has an authentication field
    if (!message.auth) {
      this.logger.warn('Message missing authentication', { messageId: message.requestId });
      return false;
    }
    
    // Add actual authentication verification logic here
    // For example, verify JWT tokens, API keys, etc.
    
    return true;
  }
  
  /**
   * Encrypt a message
   * @param {Object} message - Message to encrypt
   * @returns {Object} - Encrypted message
   * @private
   */
  _encryptMessage(message) {
    try {
      if (!this.encryptionEnabled) {
        return message;
      }
      
      // Convert message to string
      const messageStr = JSON.stringify(message);
      
      // Create an initialization vector
      const iv = crypto.randomBytes(16);
      
      // Create cipher
      const cipher = crypto.createCipheriv(
        'aes-256-cbc',
        Buffer.from(this.encryptionKey, 'hex'),
        iv
      );
      
      // Encrypt message
      let encrypted = cipher.update(messageStr, 'utf8', 'base64');
      encrypted += cipher.final('base64');
      
      // Return encrypted message with IV
      return {
        encrypted: true,
        iv: iv.toString('hex'),
        data: encrypted,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      this.logger.error('Error encrypting message', {
        error: error.message
      });
      return message;
    }
  }
  
  /**
   * Decrypt a message
   * @param {Object} encryptedMessage - Encrypted message
   * @returns {Object} - Decrypted message
   * @private
   */
  _decryptMessage(encryptedMessage) {
    try {
      if (!this.encryptionEnabled || !encryptedMessage.encrypted) {
        return encryptedMessage;
      }
      
      // Get IV and encrypted data
      const iv = Buffer.from(encryptedMessage.iv, 'hex');
      const encryptedData = encryptedMessage.data;
      
      // Create decipher
      const decipher = crypto.createDecipheriv(
        'aes-256-cbc',
        Buffer.from(this.encryptionKey, 'hex'),
        iv
      );
      
      // Decrypt message
      let decrypted = decipher.update(encryptedData, 'base64', 'utf8');
      decrypted += decipher.final('utf8');
      
      // Parse decrypted message
      return JSON.parse(decrypted);
    } catch (error) {
      this.logger.error('Error decrypting message', {
        error: error.message
      });
      throw new Error('Failed to decrypt message');
    }
  }
}

module.exports = PentestCommunicator;
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const fs = require('fs');
const path = require('path');
const zlib = require('zlib');
const readline = require('readline');
const stream = require('stream');
const { promisify } = require('util');
const pipeline = promisify(stream.pipeline);

/**
 * PentestLogManager - Manages logs for the pentest plugin
 * 
 * This class handles log rotation, compression, searching, and cleanup
 * for all logs generated by the pentest plugin.
 */
class PentestLogManager {
  /**
   * Constructor for PentestLogManager
   * @param {Object} options - Configuration options
   * @param {Object} options.logger - Logger instance
   * @param {Object} options.config - Logging configuration
   * @param {string} options.pluginId - Unique plugin identifier
   */
  constructor(options) {
    this.logger = options.logger;
    this.config = options.config || {};
    this.pluginId = options.pluginId;
    this.logsDir = path.resolve(process.cwd(), 'private/plugins/modules/pentest/logs');
    this.maxLogSize = this.config.maxLogSize || 50 * 1024 * 1024; // 50 MB
    this.retentionDays = this.config.retentionDays || 30;
    this.logRotationInterval = this.config.logRotationInterval || 86400000; // 24 hours
    this.rotationTimer = null;
    this.logStreams = new Map();
  }
  
  /**
   * Initialize the log manager
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      this.logger.info('Initializing PentestLogManager');
      
      // Create logs directory if it doesn't exist
      if (!fs.existsSync(this.logsDir)) {
        fs.mkdirSync(this.logsDir, { recursive: true });
        this.logger.info(`Created logs directory: ${this.logsDir}`);
      }
      
      // Create subdirectories for different log types
      this._createLogSubdirectories();
      
      // Schedule log rotation
      this._scheduleLogRotation();
      
      // Clean up old logs
      await this.cleanupOldLogs();
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize PentestLogManager', { 
        error: error.message,
        stack: error.stack 
      });
      throw error;
    }
  }
  
  /**
   * Create log subdirectories
   * @private
   */
  _createLogSubdirectories() {
    const subdirs = [
      'scans',
      'pentests',
      'alerts',
      'snort',
      'nmap',
      'system'
    ];
    
    for (const subdir of subdirs) {
      const dirPath = path.join(this.logsDir, subdir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        this.logger.debug(`Created log subdirectory: ${dirPath}`);
      }
    }
  }
  
  /**
   * Schedule log rotation
   * @private
   */
  _scheduleLogRotation() {
    // Clear any existing rotation timer
    if (this.rotationTimer) {
      clearInterval(this.rotationTimer);
    }
    
    // Schedule log rotation
    this.rotationTimer = setInterval(() => {
      this.rotateAllLogs().catch(error => {
        this.logger.error('Error during scheduled log rotation', {
          error: error.message
        });
      });
    }, this.logRotationInterval);
    
    this.logger.info('Scheduled log rotation', {
      interval: `${this.logRotationInterval / (60 * 60 * 1000)} hours`
    });
  }
  
  /**
   * Get a log stream for writing
   * @param {string} logType - Type of log
   * @param {string} [filename] - Custom filename (optional)
   * @returns {stream.Writable} - Log write stream
   */
  getLogStream(logType, filename) {
    try {
      // Normalize log type
      const normalizedType = logType.toLowerCase();
      
      // Determine the log directory
      let logDir;
      switch (normalizedType) {
        case 'scan':
        case 'scans':
          logDir = path.join(this.logsDir, 'scans');
          break;
        case 'pentest':
        case 'pentests':
          logDir = path.join(this.logsDir, 'pentests');
          break;
        case 'alert':
        case 'alerts':
          logDir = path.join(this.logsDir, 'alerts');
          break;
        case 'snort':
          logDir = path.join(this.logsDir, 'snort');
          break;
        case 'nmap':
          logDir = path.join(this.logsDir, 'nmap');
          break;
        case 'system':
          logDir = path.join(this.logsDir, 'system');
          break;
        default:
          logDir = this.logsDir;
      }
      
      // Generate filename if not provided
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const logFilename = filename || `${normalizedType}-${timestamp}.log`;
      const logPath = path.join(logDir, logFilename);
      
      // Check if a stream already exists
      const streamKey = `${normalizedType}:${logFilename}`;
      if (this.logStreams.has(streamKey)) {
        return this.logStreams.get(streamKey);
      }
      
      // Create write stream
      const logStream = fs.createWriteStream(logPath, { flags: 'a' });
      
      // Store stream for later reference
      this.logStreams.set(streamKey, logStream);
      
      // Handle stream errors
      logStream.on('error', (error) => {
        this.logger.error('Error writing to log', {
          error: error.message,
          logPath
        });
      });
      
      // Handle stream close
      logStream.on('close', () => {
        this.logStreams.delete(streamKey);
      });
      
      return logStream;
    } catch (error) {
      this.logger.error('Error getting log stream', {
        error: error.message,
        logType
      });
      throw error;
    }
  }
  
  /**
   * Write to a log
   * @param {string} logType - Type of log
   * @param {string} message - Message to log
   * @param {Object} [metadata] - Additional metadata (optional)
   * @param {string} [filename] - Custom filename (optional)
   * @returns {Promise<boolean>} - True if write was successful
   */
  async writeLog(logType, message, metadata = {}, filename) {
    try {
      // Get log stream
      const logStream = this.getLogStream(logType, filename);
      
      // Create log entry
      const logEntry = {
        timestamp: new Date().toISOString(),
        message,
        ...metadata
      };
      
      // Write to log
      logStream.write(JSON.stringify(logEntry) + '\n');
      
      return true;
    } catch (error) {
      this.logger.error('Error writing log', {
        error: error.message,
        logType,
        message
      });
      return false;
    }
  }
  
  /**
   * Rotate all logs
   * @returns {Promise<Object>} - Rotation results
   */
  async rotateAllLogs() {
    try {
      this.logger.info('Rotating all logs');
      
      // Close all active log streams
      for (const [streamKey, stream] of this.logStreams.entries()) {
        stream.end();
      }
      
      // Clear log streams map
      this.logStreams.clear();
      
      // Get all log files
      const rotationResults = {
        total: 0,
        rotated: 0,
        compressed: 0,
        errors: 0
      };
      
      // Process each log subdirectory
      const subdirs = [
        'scans',
        'pentests',
        'alerts',
        'snort',
        'nmap',
        'system',
        '' // Root logs dir
      ];
      
      for (const subdir of subdirs) {
        const dirPath = path.join(this.logsDir, subdir);
        
        // Skip if directory doesn't exist
        if (!fs.existsSync(dirPath)) {
          continue;
        }
        
        // Get log files in directory
        const files = fs.readdirSync(dirPath)
          .filter(file => file.endsWith('.log'))
          .map(file => path.join(dirPath, file));
        
        rotationResults.total += files.length;
        
        // Rotate each log file
        for (const file of files) {
          try {
            const stats = fs.statSync(file);
            
            // Rotate if file is larger than max size
            if (stats.size >= this.maxLogSize) {
              await this._rotateLog(file);
              rotationResults.rotated++;
            }
          } catch (error) {
            this.logger.error('Error rotating log file', {
              error: error.message,
              file
            });
            rotationResults.errors++;
          }
        }
        
        // Compress old rotated logs
        const rotatedFiles = fs.readdirSync(dirPath)
          .filter(file => file.match(/\.log\.\d+$/))
          .map(file => path.join(dirPath, file));
        
        for (const rotatedFile of rotatedFiles) {
          try {
            await this._compressLog(rotatedFile);
            rotationResults.compressed++;
          } catch (error) {
            this.logger.error('Error compressing log file', {
              error: error.message,
              file: rotatedFile
            });
            rotationResults.errors++;
          }
        }
      }
      
      this.logger.info('Log rotation completed', { rotationResults });
      
      return rotationResults;
    } catch (error) {
      this.logger.error('Error rotating logs', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Rotate a single log file
   * @param {string} filePath - Path to log file
   * @returns {Promise<boolean>} - True if rotation was successful
   * @private
   */
  async _rotateLog(filePath) {
    try {
      // Generate rotated filename with timestamp
      const rotatedPath = `${filePath}.${Date.now()}`;
      
      // Rename the file
      fs.renameSync(filePath, rotatedPath);
      
      this.logger.debug('Rotated log file', {
        originalPath: filePath,
        rotatedPath
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to rotate log file ${filePath}: ${error.message}`);
    }
  }
  
  /**
   * Compress a log file
   * @param {string} filePath - Path to log file
   * @returns {Promise<boolean>} - True if compression was successful
   * @private
   */
  async _compressLog(filePath) {
    try {
      // Generate compressed filename
      const compressedPath = `${filePath}.gz`;
      
      // Check if already compressed
      if (fs.existsSync(compressedPath)) {
        fs.unlinkSync(compressedPath);
      }
      
      // Create read and write streams
      const readStream = fs.createReadStream(filePath);
      const writeStream = fs.createWriteStream(compressedPath);
      
      // Compress file
      await pipeline(
        readStream,
        zlib.createGzip(),
        writeStream
      );
      
      // Delete original file
      fs.unlinkSync(filePath);
      
      this.logger.debug('Compressed log file', {
        originalPath: filePath,
        compressedPath
      });
      
      return true;
    } catch (error) {
      throw new Error(`Failed to compress log file ${filePath}: ${error.message}`);
    }
  }
  
  /**
   * Clean up old logs
   * @param {number} [olderThanDays] - Delete logs older than this many days
   * @returns {Promise<Object>} - Cleanup results
   */
  async cleanupOldLogs(olderThanDays) {
    try {
      // Use configured retention days if not specified
      const retentionDays = olderThanDays || this.retentionDays;
      
      this.logger.info('Cleaning up old logs', {
        retentionDays
      });
      
      // Calculate cutoff date
      const cutoffTime = new Date();
      cutoffTime.setDate(cutoffTime.getDate() - retentionDays);
      
      const cleanupResults = {
        total: 0,
        deleted: 0,
        errors: 0
      };
      
      // Process each log subdirectory
      const subdirs = [
        'scans',
        'pentests',
        'alerts',
        'snort',
        'nmap',
        'system',
        '' // Root logs dir
      ];
      
      for (const subdir of subdirs) {
        const dirPath = path.join(this.logsDir, subdir);
        
        // Skip if directory doesn't exist
        if (!fs.existsSync(dirPath)) {
          continue;
        }
        
        // Get all log files in directory
        const files = fs.readdirSync(dirPath)
          .filter(file => file.match(/\.(log|log\.\d+|log\.\d+\.gz)$/))
          .map(file => ({
            path: path.join(dirPath, file),
            stats: fs.statSync(path.join(dirPath, file))
          }));
        
        cleanupResults.total += files.length;
        
        // Delete old files
        for (const file of files) {
          try {
            if (file.stats.mtime < cutoffTime) {
              fs.unlinkSync(file.path);
              cleanupResults.deleted++;
            }
          } catch (error) {
            this.logger.error('Error deleting old log file', {
              error: error.message,
              file: file.path
            });
            cleanupResults.errors++;
          }
        }
      }
      
      this.logger.info('Log cleanup completed', { cleanupResults });
      
      return cleanupResults;
    } catch (error) {
      this.logger.error('Error cleaning up old logs', {
        error: error.message
      });
      throw error;
    }
  }
  
  /**
   * Search logs for a pattern
   * @param {string} pattern - Pattern to search for
   * @param {Object} options - Search options
   * @param {string} options.logType - Type of log to search
   * @param {Date} options.startDate - Start date for search
   * @param {Date} options.endDate - End date for search
   * @param {number} options.limit - Maximum number of results
   * @returns {Promise<Array>} - Search results
   */
  async searchLogs(pattern, options = {}) {
    try {
      // Default options
      const searchOptions = {
        logType: options.logType || 'all',
        startDate: options.startDate || new Date(0),
        endDate: options.endDate || new Date(),
        limit: options.limit || 100
      };
      
      this.logger.info('Searching logs', {
        pattern,
        options: searchOptions
      });
      
      // Determine which directories to search
      let dirsToSearch;
      if (searchOptions.logType === 'all') {
        dirsToSearch = [
          'scans',
          'pentests',
          'alerts',
          'snort',
          'nmap',
          'system',
          '' // Root logs dir
        ];
      } else {
        switch (searchOptions.logType.toLowerCase()) {
          case 'scan':
          case 'scans':
            dirsToSearch = ['scans'];
            break;
          case 'pentest':
          case 'pentests':
            dirsToSearch = ['pentests'];
            break;
          case 'alert':
          case 'alerts':
            dirsToSearch = ['alerts'];
            break;
          case 'snort':
            dirsToSearch = ['snort'];
            break;
          case 'nmap':
            dirsToSearch = ['nmap'];
            break;
          case 'system':
            dirsToSearch = ['system'];
            break;
          default:
            dirsToSearch = [searchOptions.logType];
        }
      }
      
      // Convert pattern to regex
      const regex = new RegExp(pattern, 'i');
      
      // Initialize results array
      const results = [];
      
      // Process each directory
      for (const subdir of dirsToSearch) {
        const dirPath = path.join(this.logsDir, subdir);
        
        // Skip if directory doesn't exist
        if (!fs.existsSync(dirPath)) {
          continue;
        }
        
        // Get all log files in directory
        const files = fs.readdirSync(dirPath)
          .filter(file => file.match(/\.(log|log\.\d+)$/)) // Only search uncompressed logs
          .map(file => ({
            path: path.join(dirPath, file),
            stats: fs.statSync(path.join(dirPath, file))
          }))
          .filter(file => 
            file.stats.mtime >= searchOptions.startDate && 
            file.stats.mtime <= searchOptions.endDate
          )
          .sort((a, b) => b.stats.mtime - a.stats.mtime); // Newest first
        
        // Search each file
        for (const file of files) {
          // Skip if we've reached the limit
          if (results.length >= searchOptions.limit) {
            break;
          }
          
          // Search file
          const fileResults = await this._searchFile(file.path, regex, searchOptions.limit - results.length);
          
          // Add file info to results
          fileResults.forEach(result => {
            result.file = path.basename(file.path);
            result.directory = subdir || 'root';
          });
          
          // Add to results
          results.push(...fileResults);
        }
        
        // Stop if we've reached the limit
        if (results.length >= searchOptions.limit) {
          break;
        }
      }
      
      this.logger.info('Log search completed', {
        pattern,
        resultsFound: results.length
      });
      
      return results;
    } catch (error) {
      this.logger.error('Error searching logs', {
        error: error.message,
        pattern
      });
      throw error;
    }
  }
  
  /**
   * Search a single file for a pattern
   * @param {string} filePath - Path to file
   * @param {RegExp} regex - Regular expression to search for
   * @param {number} limit - Maximum number of results
   * @returns {Promise<Array>} - Search results
   * @private
   */
  async _searchFile(filePath, regex, limit) {
    return new Promise((resolve, reject) => {
      try {
        const results = [];
        
        // Create read stream and readline interface
        const readStream = fs.createReadStream(filePath);
        const rl = readline.createInterface({
          input: readStream,
          crlfDelay: Infinity
        });
        
        // Counter for line number
        let lineNumber = 0;
        
        // Process each line
        rl.on('line', (line) => {
          lineNumber++;
          
          // Skip empty lines
          if (!line.trim()) {
            return;
          }
          
          // Test for match
          if (regex.test(line)) {
            try {
              // Try to parse as JSON
              const logEntry = JSON.parse(line);
              
              // Add match
              results.push({
                line: lineNumber,
                timestamp: logEntry.timestamp,
                message: logEntry.message,
                metadata: { ...logEntry }
              });
            } catch (parseError) {
              // Not JSON, add as raw text
              results.push({
                line: lineNumber,
                raw: line
              });
            }
            
            // Stop if we've reached the limit
            if (results.length >= limit) {
              rl.close();
              readStream.close();
            }
          }
        });
        
        // Handle end of file
        rl.on('close', () => {
          resolve(results);
        });
        
        // Handle errors
        readStream.on('error', (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  
  /**
   * Stop the log manager
   * @returns {Promise<boolean>} - True if stop was successful
   */
  async stop() {
    try {
      this.logger.info('Stopping PentestLogManager');
      
      // Clear rotation timer
      if (this.rotationTimer) {
        clearInterval(this.rotationTimer);
        this.rotationTimer = null;
      }
      
      // Close all log streams
      const closePromises = [];
      for (const [streamKey, stream] of this.logStreams.entries()) {
        closePromises.push(
          new Promise(resolve => {
            stream.end(() => {
              resolve();
            });
          })
        );
      }
      
      // Wait for all streams to close
      await Promise.all(closePromises);
      
      // Clear log streams map
      this.logStreams.clear();
      
      this.logger.info('PentestLogManager stopped successfully');
      
      return true;
    } catch (error) {
      this.logger.error('Error stopping PentestLogManager', {
        error: error.message
      });
      throw error;
    }
  }
}

module.exports = PentestLogManager;
```


```dockerfile
# Use the official Snort3 image as a base
FROM snort3/snort

# Set metadata
LABEL maintainer="IQSMS Security Team"
LABEL description="Pentest plugin with Snort IDS and security tools"
LABEL version="1.0.0"

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV SNORT_HOME=/usr/local/snort
ENV PATH=$SNORT_HOME/bin:$PATH

# Install additional tools
RUN apt-get update && apt-get install -y \
    nmap \
    curl \
    wget \
    git \
    python3 \
    python3-pip \
    unzip \
    net-tools \
    iputils-ping \
    tcpdump \
    netcat \
    iproute2 \
    openssh-client \
    dnsutils \
    whois \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Daemonlogger
WORKDIR /opt
RUN git clone https://github.com/Cisco-Talos/Daemonlogger.git \
    && cd Daemonlogger \
    && ./configure && make && make install \
    && ln -s /usr/local/bin/daemonlogger /usr/bin/daemonlogger

# Install additional Python tools
RUN pip3 install --no-cache-dir \
    scapy \
    requests \
    pyyaml \
    python-nmap

# Create required directories
RUN mkdir -p /var/log/snort \
    /etc/snort/rules \
    /etc/snort/rules/custom \
    /etc/snort/appid \
    /pcaps \
    /reports

# Copy configurations
COPY configs/snort.conf /etc/snort/snort.conf
COPY configs/local.rules /etc/snort/rules/local.rules

# Add entrypoint script
COPY scripts/entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# Set volumes
VOLUME ["/etc/snort", "/var/log/snort", "/pcaps", "/reports"]

# Set working directory
WORKDIR /usr/local/snort

# Expose ports (Snort WebUI if enabled)
EXPOSE 8080

# Set entrypoint
ENTRYPOINT ["/entrypoint.sh"]

# Default command (run Snort in IDS mode)
CMD ["--help"]
```


```
# Snort 3 Configuration File
# Generated for IQSMS Pentest Plugin

# Configure the detection engine
detection:
    # Enable or disable the entire detection engine
    enable_builtin_rules: true
    
    # Set the inspection policy mode
    inspect_stream_inserts: true
    
    # Set the maximum pattern match length
    max_pattern_len: 20000
    
    # Set the maximum queue events
    max_queue_events: 10

# Configure the basic network settings
network:
    # Set the default action for traffic
    action: alert
    
    # Configure checksum verification
    checksum_eval: all
    checksum_drop: none
    
    # Set the default VLAN handling
    vlan_agnostic: false

# Configure decoding
decode:
    # Set the maximum frame depth
    max_tcp_sessions: 262144
    max_udp_sessions: 131072

# Configure stream processing
stream:
    # Enable TCP, UDP and ICMP stream reassembly
    tcp: yes
    udp: yes
    icmp: yes
    
    # Set TCP stream options
    tcp_prune_log_max: 1GB
    
    # Set reassembly options
    max_flows: 1048576
    
    # Set timeouts
    idle_timeout: 3600

# Configure output formats
output:
    # Configure logging
    logdir: /var/log/snort
    
    # Configure alert output
    alert_csv:
        file: /var/log/snort/alert.csv
    
    # Configure unified2 output
    unified2:
        filename: snort.u2
        limit: 128

# Include rules
include /etc/snort/rules/local.rules
include_path /etc/snort/rules

# Search for Snort rule files with these extensions
rule_paths:
    /etc/snort/rules: .rules .txt

# Configure reputation preprocessing
reputation:
    # Include IP blacklist and whitelist if they exist
    blocklist: /etc/snort/rules/ip-blocklist.blf
    allowlist: /etc/snort/rules/ip-allowlist.blf

# Configure app ID
appid:
    app_detector_dir: /etc/snort/appid
    log_stats: true
```


```
# Local rules for IQSMS Pentest Plugin

# Test rule - alerts on ICMP echo requests (ping)
alert icmp any any -> any any (msg:"ICMP Echo Request"; itype:8; metadata:rule-type test; sid:10000001; rev:1;)

# Detect port scanning activity
alert tcp any any -> any any (msg:"NMAP TCP Scan"; flags:S; threshold: type threshold, track by_src, count 20, seconds 60; metadata:rule-type scan_detection; sid:10000002; rev:1;)

# Detect SSH brute force attempts
alert tcp any any -> any 22 (msg:"Potential SSH Brute Force Attack"; flow:to_server; threshold: type threshold, track by_src, count 5, seconds 60; metadata:rule-type brute_force; sid:10000003; rev:1;)

# Detect FTP brute force attempts
alert tcp any any -> any 21 (msg:"Potential FTP Brute Force Attack"; flow:to_server; content:"USER"; threshold: type threshold, track by_src, count 5, seconds 60; metadata:rule-type brute_force; sid:10000004; rev:1;)

# Detect HTTP directory traversal attempts
alert tcp any any -> any 80 (msg:"
I'll continue developing the pentest plugin for your network security infrastructure. Let me implement the remaining components and scripts required for a complete solution.

```
# Local rules for IQSMS Pentest Plugin

# Test rule - alerts on ICMP echo requests (ping)
alert icmp any any -> any any (msg:"ICMP Echo Request"; itype:8; metadata:rule-type test; sid:10000001; rev:1;)

# Detect port scanning activity
alert tcp any any -> any any (msg:"NMAP TCP Scan"; flags:S; threshold: type threshold, track by_src, count 20, seconds 60; metadata:rule-type scan_detection; sid:10000002; rev:1;)

# Detect SSH brute force attempts
alert tcp any any -> any 22 (msg:"Potential SSH Brute Force Attack"; flow:to_server; threshold: type threshold, track by_src, count 5, seconds 60; metadata:rule-type brute_force; sid:10000003; rev:1;)

# Detect FTP brute force attempts
alert tcp any any -> any 21 (msg:"Potential FTP Brute Force Attack"; flow:to_server; content:"USER"; threshold: type threshold, track by_src, count 5, seconds 60; metadata:rule-type brute_force; sid:10000004; rev:1;)

# Detect HTTP directory traversal attempts
alert tcp any any -> any 80 (msg:"HTTP Directory Traversal Attempt"; flow:to_server; content:"|2E 2E 2F|"; http_uri; pcre:"/\.\.[\\/]/Ui"; metadata:rule-type web_attack; sid:10000005; rev:1;)

# Detect SQL injection attempts
alert tcp any any -> any any (msg:"SQL Injection Attempt"; flow:to_server; content:"SELECT"; nocase; pcre:"/SELECT.+FROM.+WHERE/i"; metadata:rule-type web_attack; sid:10000006; rev:1;)

# Detect potential command injection
alert tcp any any -> any any (msg:"Command Injection Attempt"; flow:to_server; content:"|3B|"; pcre:"/(;|\||\|\||&&).*(sh|bash|cmd|powershell)/i"; metadata:rule-type web_attack; sid:10000007; rev:1;)

# Detect potential XSS attempts
alert tcp any any -> any 80 (msg:"Cross-Site Scripting Attempt"; flow:to_server; content:"<script>"; nocase; metadata:rule-type web_attack; sid:10000008; rev:1;)

# Detect unusual outbound connections
alert tcp any any -> any !80 !443 !22 !53 (msg:"Unusual Outbound Connection"; flow:to_server; flags:S; threshold: type threshold, track by_src, count 5, seconds 60; metadata:rule-type suspicious_traffic; sid:10000009; rev:1;)

# Detect potential data exfiltration (large outbound transfer)
alert tcp any any -> any any (msg:"Potential Data Exfiltration"; flow:to_server; byte_test:10000,>,dsize; threshold: type threshold, track by_src, count 5, seconds 300; metadata:rule-type data_leakage; sid:10000010; rev:1;)

# Detect potential malware communication (known C2 patterns)
alert tcp any any -> any any (msg:"Potential C2 Communication"; flow:to_server; content:"beacon"; nocase; metadata:rule-type malware; sid:10000011; rev:1;)

# Detect clear text credentials
alert tcp any any -> any any (msg:"Clear Text Password"; flow:to_server; content:"password="; nocase; metadata:rule-type credential_exposure; sid:10000012; rev:1;)

# Detect potential DNS tunneling
alert udp any any -> any 53 (msg:"Potential DNS Tunneling"; content:"|00 01 00 00|"; offset:4; depth:4; byte_test:1,>,35,0,relative; metadata:rule-type tunneling; sid:10000013; rev:1;)

# Detect network reconnaissance via ICMP
alert icmp any any -> any any (msg:"ICMP Network Reconnaissance"; threshold: type threshold, track by_src, count 15, seconds 60; metadata:rule-type reconnaissance; sid:10000014; rev:1;)

# Detect internal port scanning
alert tcp $HOME_NET any -> $HOME_NET any (msg:"Internal Port Scanning"; flags:S; threshold: type threshold, track by_src, count 30, seconds 60; metadata:rule-type internal_threat; sid:10000015; rev:1;)
```


```shell script
#!/bin/bash
# Entry point script for Pentest Plugin Docker container

# Set default configuration
INTERFACE=${INTERFACE:-eth0}
MODE=${MODE:-ids}
LOG_DIR=${LOG_DIR:-/var/log/snort}
RULES_DIR=${RULES_DIR:-/etc/snort/rules}
PCAP_DIR=${PCAP_DIR:-/pcaps}
CONFIG_FILE=${CONFIG_FILE:-/etc/snort/snort.conf}
VERBOSE=${VERBOSE:-0}

# Create log directories if they don't exist
mkdir -p ${LOG_DIR}/{alert,fast,full,pcap}

# Check for rule updates
if [ "$UPDATE_RULES" = "true" ]; then
    echo "Checking for rule updates..."
    if [ -f /opt/update-rules.sh ]; then
        /opt/update-rules.sh
    fi
fi

# Define functions
function run_snort_ids() {
    echo "Starting Snort in IDS mode on interface ${INTERFACE}..."
    
    # Add verbosity if requested
    VERBOSITY=""
    if [ "$VERBOSE" -eq "1" ]; then
        VERBOSITY="-v"
    elif [ "$VERBOSE" -eq "2" ]; then
        VERBOSITY="-vv"
    elif [ "$VERBOSE" -gt "2" ]; then
        VERBOSITY="-vvv"
    fi
    
    # Run Snort with configured options
    exec snort -c ${CONFIG_FILE} -i ${INTERFACE} -l ${LOG_DIR} ${VERBOSITY} -A console -k none
}

function run_snort_test() {
    echo "Testing Snort configuration..."
    exec snort -c ${CONFIG_FILE} -T
}

function run_snort_pcap() {
    if [ -z "$PCAP_FILE" ]; then
        echo "Error: PCAP_FILE environment variable must be set for pcap mode"
        exit 1
    fi
    
    PCAP_PATH="${PCAP_DIR}/${PCAP_FILE}"
    
    if [ ! -f "$PCAP_PATH" ]; then
        echo "Error: PCAP file ${PCAP_PATH} not found"
        exit 1
    fi
    
    echo "Processing PCAP file: ${PCAP_PATH}"
    exec snort -c ${CONFIG_FILE} -r ${PCAP_PATH} -l ${LOG_DIR} -A csv
}

function run_daemonlogger() {
    echo "Starting Daemonlogger on interface ${INTERFACE}..."
    exec daemonlogger -d -i ${INTERFACE} -l ${PCAP_DIR}
}

function run_nmap_scan() {
    if [ -z "$SCAN_TARGET" ]; then
        echo "Error: SCAN_TARGET environment variable must be set for nmap mode"
        exit 1
    fi
    
    NMAP_OPTIONS=${NMAP_OPTIONS:-"-sV -sC"}
    OUTPUT_FILE="${LOG_DIR}/nmap-scan-$(date +%Y%m%d-%H%M%S).xml"
    
    echo "Running Nmap scan against ${SCAN_TARGET} with options: ${NMAP_OPTIONS}"
    exec nmap ${NMAP_OPTIONS} ${SCAN_TARGET} -oX ${OUTPUT_FILE}
}

# Handle different run modes
case "$MODE" in
    ids)
        run_snort_ids
        ;;
    test)
        run_snort_test
        ;;
    pcap)
        run_snort_pcap
        ;;
    capture)
        run_daemonlogger
        ;;
    nmap)
        run_nmap_scan
        ;;
    *)
        # If a direct command is specified, run it
        if [ "$1" != "" ]; then
            exec "$@"
        else
            echo "Unknown mode: ${MODE}"
            echo "Available modes: ids, test, pcap, capture, nmap"
            exit 1
        fi
        ;;
esac
```


```shell script
#!/bin/bash
# Script to update Snort rules

# Configuration
RULES_DIR=${RULES_DIR:-/etc/snort/rules}
BACKUP_DIR=${BACKUP_DIR:-/etc/snort/rules/backup}
TEMP_DIR=${TEMP_DIR:-/tmp/snort-rules}
COMMUNITY_RULES_URL="https://www.snort.org/downloads/community/snort3-community-rules.tar.gz"
ETPRO_RULES_URL=${ETPRO_RULES_URL:-""}
ETPRO_CODE=${ETPRO_CODE:-""}

# Create necessary directories
mkdir -p ${RULES_DIR}
mkdir -p ${BACKUP_DIR}
mkdir -p ${TEMP_DIR}

# Backup current rules
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
BACKUP_PATH="${BACKUP_DIR}/rules-backup-${TIMESTAMP}"
mkdir -p ${BACKUP_PATH}

echo "Backing up current rules to ${BACKUP_PATH}..."
cp -r ${RULES_DIR}/*.rules ${BACKUP_PATH}/ 2>/dev/null || true
cp -r ${RULES_DIR}/*.txt ${BACKUP_PATH}/ 2>/dev/null || true
cp -r ${RULES_DIR}/*.blf ${BACKUP_PATH}/ 2>/dev/null || true

# Function to download and extract community rules
function update_community_rules() {
    echo "Downloading Snort community rules..."
    curl -s -L -o ${TEMP_DIR}/community-rules.tar.gz ${COMMUNITY_RULES_URL}
    
    if [ $? -ne 0 ]; then
        echo "Error downloading community rules"
        return 1
    fi
    
    echo "Extracting community rules..."
    tar -xzf ${TEMP_DIR}/community-rules.tar.gz -C ${TEMP_DIR}
    
    if [ $? -ne 0 ]; then
        echo "Error extracting community rules"
        return 1
    fi
    
    # Find and copy rule files to rules directory
    find ${TEMP_DIR} -name "*.rules" -exec cp {} ${RULES_DIR}/ \;
    find ${TEMP_DIR} -name "*.txt" -exec cp {} ${RULES_DIR}/ \;
    find ${TEMP_DIR} -name "*.blf" -exec cp {} ${RULES_DIR}/ \;
    
    echo "Community rules updated successfully"
    return 0
}

# Function to download and extract ET Pro rules (if configured)
function update_etpro_rules() {
    if [ -z "${ETPRO_RULES_URL}" ] || [ -z "${ETPRO_CODE}" ]; then
        echo "ET Pro rules not configured, skipping"
        return 0
    fi
    
    echo "Downloading ET Pro rules..."
    curl -s -L -o ${TEMP_DIR}/etpro-rules.tar.gz "${ETPRO_RULES_URL}?oinkcode=${ETPRO_CODE}"
    
    if [ $? -ne 0 ]; then
        echo "Error downloading ET Pro rules"
        return 1
    fi
    
    echo "Extracting ET Pro rules..."
    tar -xzf ${TEMP_DIR}/etpro-rules.tar.gz -C ${TEMP_DIR}
    
    if [ $? -ne 0 ]; then
        echo "Error extracting ET Pro rules"
        return 1
    fi
    
    # Find and copy rule files to rules directory
    find ${TEMP_DIR} -name "*.rules" -exec cp {} ${RULES_DIR}/ \;
    find ${TEMP_DIR} -name "*.txt" -exec cp {} ${RULES_DIR}/ \;
    find ${TEMP_DIR} -name "*.blf" -exec cp {} ${RULES_DIR}/ \;
    
    echo "ET Pro rules updated successfully"
    return 0
}

# Update IP blacklists
function update_ip_blacklists() {
    echo "Downloading IP blacklist..."
    curl -s -L -o ${RULES_DIR}/ip-blocklist.blf "https://snort-org-site.s3.amazonaws.com/production/document_files/files/000/041/972/original/ip-filter.blf"
    
    if [ $? -ne 0 ]; then
        echo "Error downloading IP blacklist"
        return 1
    fi
    
    echo "IP blacklist updated successfully"
    return 0
}

# Execute update functions
echo "Starting rule updates at $(date)"

update_community_rules
COMMUNITY_RESULT=$?

update_etpro_rules
ETPRO_RESULT=$?

update_ip_blacklists
BLACKLIST_RESULT=$?

# Clean up
rm -rf ${TEMP_DIR}

# Create update metadata
cat > ${RULES_DIR}/update-metadata.json << EOF
{
  "lastUpdate": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "communityRulesUpdated": ${COMMUNITY_RESULT},
  "etProRulesUpdated": ${ETPRO_RESULT},
  "blacklistUpdated": ${BLACKLIST_RESULT}
}
EOF

echo "Rule update completed at $(date)"

# Return overall status
if [ ${COMMUNITY_RESULT} -eq 0 ] && [ ${BLACKLIST_RESULT} -eq 0 ]; then
    exit 0
else
    exit 1
fi
```


```json
{
  "name": "pentest-plugin",
  "version": "1.0.0",
  "description": "Network security and penetration testing plugin for IQSMS",
  "main": "PentestPlugin.js",
  "scripts": {
    "test": "jest",
    "build-docker": "docker build -t pentest-plugin .",
    "start": "node start.js",
    "update-rules": "node scripts/update-rules.js"
  },
  "keywords": [
    "security",
    "pentest",
    "network",
    "snort",
    "intrusion-detection",
    "vulnerability-scanning"
  ],
  "author": "IQSMS Security Team",
  "license": "UNLICENSED",
  "private": true,
  "dependencies": {
    "axios": "^1.6.2",
    "cron": "^2.3.1",
    "mongodb": "^5.0.0",
    "node-cron": "^3.0.2",
    "uuid": "^9.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "jest": "^29.5.0"
  }
}
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const PentestPlugin = require('./PentestPlugin');
const { MongoClient } = require('mongodb');
const path = require('path');
const fs = require('fs');

// Configure logger
const logger = {
  info: (message, meta = {}) => console.log(`[INFO] ${message}`, meta),
  warn: (message, meta = {}) => console.warn(`[WARN] ${message}`, meta),
  error: (message, meta = {}) => console.error(`[ERROR] ${message}`, meta),
  debug: (message, meta = {}) => console.debug(`[DEBUG] ${message}`, meta)
};

// Mock message bus for standalone operation
const messageBus = {
  publish: async (topic, message) => {
    logger.info(`Publishing to ${topic}`, { message });
    return true;
  },
  subscribe: async (topic, handler) => {
    logger.info(`Subscribed to ${topic}`);
    return true;
  }
};

// Mock monitoring service
const monitoring = {
  registerMetric: (metric) => {
    logger.info(`Registered metric: ${metric.name}`);
  },
  registerAlert: (alert) => {
    logger.info(`Registered alert: ${alert.name}`);
  },
  reportMetric: (name, value, labels) => {
    logger.info(`Reporting metric: ${name}`, { value, labels });
  },
  reportAlert: (name, title, description, details, severity) => {
    logger.info(`Reporting alert: ${name}`, { title, description, severity });
  }
};

// Load configuration
const configPath = path.join(__dirname, 'config.json');
let config = {};

try {
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    logger.info('Configuration loaded from config.json');
  } else {
    logger.warn('config.json not found, using default configuration');
  }
} catch (error) {
  logger.error('Error loading configuration', { error: error.message });
}

// Connect to MongoDB
async function connectToMongoDB() {
  try {
    const mongoUrl = process.env.MONGO_URL || 'mongodb://localhost:27017';
    const client = new MongoClient(mongoUrl);
    await client.connect();
    logger.info('Connected to MongoDB');
    return client.db('pentest');
  } catch (error) {
    logger.error('Failed to connect to MongoDB', { error: error.message });
    throw error;
  }
}

// Start the plugin
async function startPlugin() {
  try {
    // Connect to database
    const db = await connectToMongoDB();
    
    // Create and initialize the plugin
    const plugin = new PentestPlugin({
      logger,
      config,
      messageBus,
      db,
      monitoring
    });
    
    // Initialize the plugin
    await plugin.init();
    
    // Start the plugin
    await plugin.start();
    
    logger.info('Pentest plugin started successfully');
    
    // Handle shutdown signals
    process.on('SIGINT', async () => {
      logger.info('Received SIGINT, shutting down...');
      await plugin.stop();
      process.exit(0);
    });
    
    process.on('SIGTERM', async () => {
      logger.info('Received SIGTERM, shutting down...');
      await plugin.stop();
      process.exit(0);
    });
    
    return plugin;
  } catch (error) {
    logger.error('Failed to start plugin', { error: error.message });
    process.exit(1);
  }
}

// Run the plugin
if (require.main === module) {
  startPlugin();
}

module.exports = { startPlugin };
```


```javascript
/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const zlib = require('zlib');
const stream = require('stream');
const pipeline = promisify(stream.pipeline);
const tar = require('tar');

// Configure logger
const logger = {
  info: (message, meta = {}) => console.log(`[INFO] ${message}`, meta),
  warn: (message, meta = {}) => console.warn(`[WARN] ${message}`, meta),
  error: (message, meta = {}) => console.error(`[ERROR] ${message}`, meta),
  debug: (message, meta = {}) => console.debug(`[DEBUG] ${message}`, meta)
};

// Configuration
const config = {
  rulesDir: process.env.RULES_DIR || path.resolve(__dirname, '../rules'),
  backupDir: process.env.BACKUP_DIR || path.resolve(__dirname, '../rules/backup'),
  tempDir: process.env.TEMP_DIR || path.resolve(__dirname, '../rules/temp'),
  communityRulesUrl: process.env.COMMUNITY_RULES_URL || 'https://www.snort.org/downloads/community/snort3-community-rules.tar.gz',
  etproRulesUrl: process.env.ETPRO_RULES_URL || '',
  etproCode: process.env.ETPRO_CODE || '',
  ipBlacklistUrl: process.env.IP_BLACKLIST_URL || 'https://snort-org-site.s3.amazonaws.com/production/document_files/files/000/041/972/original/ip-filter.blf'
};

/**
 * Create necessary directories
 */
async function createDirectories() {
  try {
    // Create rules directory if it doesn't exist
    if (!fs.existsSync(config.rulesDir)) {
      fs.mkdirSync(config.rulesDir, { recursive: true });
      logger.info(`Created rules directory: ${config.rulesDir}`);
    }
    
    // Create backup directory if it doesn't exist
    if (!fs.existsSync(config.backupDir)) {
      fs.mkdirSync(config.backupDir, { recursive: true });
      logger.info(`Created backup directory: ${config.backupDir}`);
    }
    
    // Create temp directory if it doesn't exist
    if (!fs.existsSync(config.tempDir)) {
      fs.mkdirSync(config.tempDir, { recursive: true });
      logger.info(`Created temp directory: ${config.tempDir}`);
    }
  } catch (error) {
    logger.error('Error creating directories', { error: error.message });
    throw error;
  }
}

/**
 * Backup current rules
 */
async function backupRules() {
  try {
    // Create timestamped backup directory
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(config.backupDir, `rules-backup-${timestamp}`);
    fs.mkdirSync(backupPath, { recursive: true });
    
    logger.info(`Backing up current rules to ${backupPath}`);
    
    // Find rule files
    if (fs.existsSync(config.rulesDir)) {
      const files = fs.readdirSync(config.rulesDir)
        .filter(file => file.endsWith('.rules') || file.endsWith('.txt') || file.endsWith('.blf'));
      
      // Copy files to backup directory
      for (const file of files) {
        const sourcePath = path.join(config.rulesDir, file);
        const destPath = path.join(backupPath, file);
        fs.copyFileSync(sourcePath, destPath);
      }
      
      logger.info(`Backed up ${files.length} rule files`);
    } else {
      logger.warn(`Rules directory ${config.rulesDir} does not exist`);
    }
    
    return backupPath;
  } catch (error) {
    logger.error('Error backing up rules', { error: error.message });
    throw error;
  }
}

/**
 * Download a file from a URL
 * @param {string} url - URL to download from
 * @param {string} outputPath - Path to save the file
 */
async function downloadFile(url, outputPath) {
  try {
    logger.info(`Downloading from ${url} to ${outputPath}`);
    
    const response = await axios({
      method: 'get',
      url: url,
      responseType: 'stream'
    });
    
    const writer = fs.createWriteStream(outputPath);
    
    await pipeline(response.data, writer);
    
    logger.info(`Download completed: ${outputPath}`);
    return true;
  } catch (error) {
    logger.error('Error downloading file', { 
      error: error.message,
      url
    });
    throw error;
  }
}

/**
 * Extract a tar.gz file
 * @param {string} filePath - Path to the tar.gz file
 * @param {string} outputDir - Directory to extract to
 */
async function extractTarGz(filePath, outputDir) {
  try {
    logger.info(`Extracting ${filePath} to ${outputDir}`);
    
    await tar.extract({
      file: filePath,
      cwd: outputDir
    });
    
    logger.info(`Extraction completed: ${outputDir}`);
    return true;
  } catch (error) {
    logger.error('Error extracting file', { 
      error: error.message,
      filePath
    });
    throw error;
  }
}

/**
 * Find rule files in a directory and its subdirectories
 * @param {string} dir - Directory to search
 * @returns {Array} - Array of file paths
 */
function findRuleFiles(dir) {
  try {
    let results = [];
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        results = results.concat(findRuleFiles(fullPath));
      } else if (file.endsWith('.rules') || file.endsWith('.txt') || file.endsWith('.blf')) {
        results.push(fullPath);
      }
    }
    
    return results;
  } catch (error) {
    logger.error('Error finding rule files', { 
      error: error.message,
      dir
    });
    return [];
  }
}

/**
 * Update Snort community rules
 */
async function updateCommunityRules() {
  try {
    logger.info('Updating Snort community rules');
    
    // Download community rules
    const tempFilePath = path.join(config.tempDir, 'community-rules.tar.gz');
    await downloadFile(config.communityRulesUrl, tempFilePath);
    
    // Extract rules
    await extractTarGz(tempFilePath, config.tempDir);
    
    // Find rule files
    const ruleFiles = findRuleFiles(config.tempDir);
    
    // Copy rule files to rules directory
    let copiedCount = 0;
    for (const file of ruleFiles) {
      const fileName = path.basename(file);
      const destPath = path.join(config.rulesDir, fileName);
      fs.copyFileSync(file, destPath);
      copiedCount++;
    }
    
    logger.info(`Updated ${copiedCount} community rule files`);
    return true;
  } catch (error) {
    logger.error('Error updating community rules', { error: error.message });
    return false;
  }
}

/**
 * Update ET Pro rules (if configured)
 */
async function updateEtProRules() {
  try {
    if (!config.etproRulesUrl || !config.etproCode) {
      logger.info('ET Pro rules not configured, skipping');
      return true;
    }
    
    logger.info('Updating ET Pro rules');
    
    // Download ET Pro rules
    const etproUrl = `${config.etproRulesUrl}?oinkcode=${config.etproCode}`;
    const tempFilePath = path.join(config.tempDir, 'etpro-rules.tar.gz');
    await downloadFile(etproUrl, tempFilePath);
    
    // Extract rules
    await extractTarGz(tempFilePath, config.tempDir);
    
    // Find rule files
    const ruleFiles = findRuleFiles(config.tempDir);
    
    // Copy rule files to rules directory
    let copiedCount = 0;
    for (const file of ruleFiles) {
      const fileName = path.basename(file);
      const destPath = path.join(config.rulesDir, fileName);
      fs.copyFileSync(file, destPath);
      copiedCount++;
    }
    
    logger.info(`Updated ${copiedCount} ET Pro rule files`);
    return true;
  } catch (error) {
    logger.error('Error updating ET Pro rules', { error: error.message });
    return false;
  }
}

/**
 * Update IP blacklist
 */
async function updateIpBlacklist() {
  try {
    logger.info('Updating IP blacklist');
    
    // Download blacklist
    const blacklistPath = path.join(config.rulesDir, 'ip-blocklist.blf');
    await downloadFile(config.ipBlacklistUrl, blacklistPath);
    
    logger.info('IP blacklist updated successfully');
    return true;
  } catch (error) {
    logger.error('Error updating IP blacklist', { error: error.message });
    return false;
  }
}

/**
 * Clean up temporary files
 */
async function cleanup() {
  try {
    // Remove all files in temp directory
    if (fs.existsSync(config.tempDir)) {
      const files = fs.readdirSync(config.tempDir);
      
      for (const file of files) {
        const filePath = path.join(config.tempDir, file);
        
        if (fs.statSync(filePath).isDirectory()) {
          fs.rmdirSync(filePath, { recursive: true });
        } else {
          fs.unlinkSync(filePath);
        }
      }
    }
    
    logger.info('Temporary files cleaned up');
    return true;
  } catch (error) {
    logger.error('Error cleaning up temporary files', { error: error.message });
    return false;
  }
}

/**
 * Update rules metadata
 * @param {Object} results - Update results
 */
function updateMetadata(results) {
  try {
    const metadataPath = path.join(config.rulesDir, 'update-metadata.json');
    
    const metadata = {
      lastUpdate: new Date().toISOString(),
      communityRulesUpdated: results.communityRules,
      etProRulesUpdated: results.etProRules,
      blacklistUpdated: results.ipBlacklist,
      backupPath: results.backupPath
    };
    
    fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    
    logger.info('Updated rules metadata');
    return true;
  } catch (error) {
    logger.error('Error updating rules metadata', { error: error.message });
    return false;
  }
}

/**
 * Main function to update all rules
 */
async function updateRules() {
  try {
    logger.info('Starting rule updates');
    
    // Create directories
    await createDirectories();
    
    // Backup current rules
    const backupPath = await backupRules();
    
    // Update rules
    const communityRules = await updateCommunityRules();
    const etProRules = await updateEtProRules();
    const ipBlacklist = await updateIpBlacklist();
    
    // Clean up
    await cleanup();
    
    // Update metadata
    const results = {
      communityRules,
      etProRules,
      ipBlacklist,
      backupPath
    };
    
    updateMetadata(results);
    
    logger.info('Rule updates completed', results);
    
    // Return overall status
    if (communityRules && ipBlacklist) {
      return true;
    } else {
      return false;
    }
  } catch (error) {
    logger.error('Error updating rules', { error: error.message });
    return false;
  }
}

// Run the update if this script is called directly
if (require.main === module) {
  updateRules()
    .then(success => {
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      logger.error('Unhandled error during rule update', { error: error.message });
      process.exit(1);
    });
}

module.exports = { updateRules };
```


```markdown
# Pentest Plugin for Network Security

## Overview

The Pentest plugin is a comprehensive security testing and monitoring solution for distributed network environments. It enables automated security scanning, vulnerability detection, and self-healing capabilities across the entire network infrastructure.

The plugin leverages Snort for intrusion detection, along with other security tools like Nmap for vulnerability scanning. It operates on a scheduled basis, performing various levels of security testing from basic hourly checks to comprehensive monthly penetration tests.

## Features

- **Automated Security Scanning**: Schedule regular security scans to identify vulnerabilities
- **Intrusion Detection**: Real-time monitoring using Snort rules
- **Penetration Testing**: Comprehensive security assessment of network infrastructure
- **Distributed Testing**: Coordinate security testing across multiple cores
- **Self-Healing**: Automatically remediate detected vulnerabilities
- **Rule Management**: Automatic updates of Snort rules and IP blacklists
- **Docker Integration**: Self-contained environment for security tools
- **Monitoring Integration**: Push security alerts to the monitoring framework

## Installation

### Prerequisites

- Node.js 14+
- Docker
- MongoDB
- IQSMS core system

### Installation Steps

1. Clone the repository into your plugins directory:
   ```
git clone https://github.com/yourusername/pentest-plugin.git private/plugins/modules/pentest
   ```

2. Install dependencies:
   ```
cd private/plugins/modules/pentest
npm install
   ```

3. Build the Docker container:
   ```
npm run build-docker
   ```

4. Configure the plugin by editing `config.json`:
   ```json
   {
     "docker": {
       "enabled": true,
       "baseImage": "snort3/snort",
       "containerName": "pentest-snort-container"
     },
     "rules": {
       "updateInterval": 86400000,
       "snortRulesUrl": "https://www.snort.org/downloads/community/snort3-community-rules.tar.gz"
     },
     "scanners": {
       "nmap": {
         "enabled": true,
         "scheduledScans": {
           "quickScan": {
             "cronSchedule": "0 * * * *",
             "targets": "localnet",
             "options": "-sV -F --open"
           },
           "fullScan": {
             "cronSchedule": "0 0 * * 0",
             "targets": "localnet",
             "options": "-sV -O -A"
           }
         }
       },
       "snort": {
         "enabled": true,
         "configFile": "/etc/snort/snort.conf",
         "interfaces": ["eth0"]
       }
     },
     "scheduler": {
       "pentestSchedule": "0 0 * * 1",
       "pressureTestSchedule": "0 0 1 * *"
     }
   }
   ```

5. Register the plugin with your IQSMS system

## Usage

### Starting the Plugin

The plugin can be started as part of your IQSMS system or standalone for testing:
```

npm start
```
### Manual Operations

You can manually trigger operations using the CLI:
```

# Update Snort rules
npm run update-rules

# Run a quick scan
node cli.js run-scan --type nmap --target localhost

# Run a comprehensive pentest
node cli.js run-pentest --type comprehensive --target local
```
### Docker Operations

You can run operations directly in the Docker container:
```

# Start Snort in IDS mode
docker run -d --name pentest-snort --network host -v ./rules:/etc/snort/rules -v ./logs:/var/log/snort pentest-plugin

# Process a PCAP file
docker run --rm -v ./pcaps:/pcaps -v ./logs:/var/log/snort -e MODE=pcap -e PCAP_FILE=capture.pcap pentest-plugin

# Run an Nmap scan
docker run --rm -v ./logs:/var/log/snort -e MODE=nmap -e SCAN_TARGET=192.168.1.0/24 -e NMAP_OPTIONS="-sV -F" pentest-plugin
```
## Plugin Architecture

The plugin consists of several components:

- **PentestPlugin**: Main class that orchestrates all operations
- **DockerContainerManager**: Manages Docker containers for security tools
- **SnortRulesManager**: Handles Snort rule updates and management
- **ScannerManager**: Coordinates different scanning tools
- **ReportingSystem**: Processes scan results and generates reports
- **PentestScheduler**: Schedules and manages security testing tasks
- **PentestCommunicator**: Enables communication between cores
- **PentestLogManager**: Manages logs and log rotation

## Configuration

### Main Configuration Options

| Option | Description | Default |
|--------|-------------|---------|
| docker.enabled | Enable Docker integration | true |
| docker.baseImage | Base Docker image | snort3/snort |
| docker.containerName | Name of the Docker container | pentest-snort-container |
| rules.updateInterval | Interval for rule updates in ms | 86400000 (24 hours) |
| rules.snortRulesUrl | URL for Snort community rules | https://www.snort.org/downloads/community/snort3-community-rules.tar.gz |
| scanners.nmap.enabled | Enable Nmap scanning | true |
| scanners.snort.enabled | Enable Snort detection | true |
| scanners.snort.interfaces | Network interfaces to monitor | ["eth0"] |
| scheduler.pentestSchedule | Cron schedule for pentests | 0 0 * * 1 (Weekly on Monday) |
| scheduler.pressureTestSchedule | Cron schedule for pressure tests | 0 0 1 * * (Monthly on the 1st) |

## Integration with Monitoring Framework

The plugin integrates with the IQSMS monitoring framework to report metrics and alerts:

### Metrics

- `pentest_plugin_status`: Current status of the plugin
- `pentest_scans_total`: Total number of security scans performed
- `pentest_vulnerabilities_detected`: Number of vulnerabilities detected
- `pentest_rule_updates`: Number of rule updates performed

### Alerts

- `high_severity_vulnerability`: Triggered when a high severity vulnerability is detected
- `scan_failure`: Triggered when a scan fails
- `pentest_failure`: Triggered when a pentest fails
- `self_healing_failure`: Triggered when self-healing fails

## Self-Healing Capabilities

The plugin can automatically remediate certain types of vulnerabilities:

- **Port Restrictions**: Automatically configure firewall rules to restrict open ports
- **IP Blocking**: Block IPs associated with malicious activity
- **Service Patching**: Apply patches to vulnerable services

## Distributed Testing

The plugin supports distributed testing across multiple cores:

1. The initiating core sends a pentest request to other cores
2. Each core performs local security testing
3. Results are aggregated and reported back to the initiating core
4. Critical vulnerabilities trigger self-healing actions

## License

Copyright 2025 Autonomy Association International Inc., all rights reserved
Safeguard patent license from National Aeronautics and Space Administration (NASA)
Copyright 2025 NASA, all rights reserved
```


```javascript
#!/usr/bin/env node

/**
 * Copyright 2025 Autonomy Association International Inc., all rights reserved
 * Safeguard patent license from National Aeronautics and Space Administration (NASA)
 * Copyright 2025 NASA, all rights reserved
 */

const { startPlugin } = require('./start');
const { updateRules } = require('./scripts/update-rules');
const path = require('path');
const fs = require('fs');

// Configure logger
const logger = {
  info: (message, meta = {}) => console.log(`[INFO] ${message}`, meta),
  warn: (message, meta = {}) => console.warn(`[WARN] ${message}`, meta),
  error: (message, meta = {}) => console.error(`[ERROR] ${message}`, meta),
  debug: (message, meta = {}) => console.debug(`[DEBUG] ${message}`, meta)
};

// Parse command line arguments
const args = process.argv.slice(2);
const command = args[0];

// Get options from arguments
function getOption(name, defaultValue) {
  const index = args.indexOf(`--${name}`);
  if (index === -1) return defaultValue;
  
  const value = args[index + 1];
  if (!value || value.startsWith('--')) return true;
  
  return value;
}

// Display help message
function showHelp() {
  console.log(`
Pentest Plugin CLI

Usage:
  node cli.js <command> [options]

Commands:
  start                     Start the plugin
  update-rules              Update Snort rules
  run-scan                  Run a security scan
  run-pentest               Run a penetration test
  get-status                Get plugin status
  help                      Show this help message

Options:
  --type <type>             Type of scan or pentest
  --target <target>         Target to scan
  --options <options>       Additional options
  --priority <priority>     Priority level
  --config <path>           Path to config file
  
Examples:
  node cli.js start
  node cli.js update-rules
  node cli.js run-scan --type nmap --target localhost
  node cli.js run-pentest --type comprehensive --target local
  node cli.js get-status
  `);
}

// Main function
async function main() {
  try {
    switch (command) {
      case 'start':
        logger.info('Starting plugin...');
        await startPlugin();
        break;
        
      case 'update-rules':
        logger.info('Updating Snort rules...');
        const success = await updateRules();
        logger.info(`Rule update ${success ? 'succeeded' : 'failed'}`);
        process.exit(success ? 0 : 1);
        break;
        
      case 'run-scan':
        logger.info('Running security scan...');
        const scanType = getOption('type', 'nmap');
        const scanTarget = getOption('target', 'localhost');
        const scanOptions = getOption('options', '');
        const scanPriority = getOption('priority', 'normal');
        
        // Start plugin
        const scanPlugin = await startPlugin();
        
        // Queue scan task
        const scanTask = await scanPlugin.penitentCollection.insertOne({
          taskType: 'scan',
          scanType,
          targetId: scanTarget,
          scanOptions,
          priority: scanPriority,
          status: 'pending',
          createdAt: new Date(),
          scheduledTime: new Date()
        });
        
        logger.info(`Scan task queued with ID ${scanTask.insertedId}`);
        
        // Process the task
        await scanPlugin._processNextPendingTask();
        
        // Keep process alive until task completes
        await waitForTaskCompletion(scanPlugin, scanTask.insertedId);
        
        await scanPlugin.stop();
        process.exit(0);
        break;
        
      case 'run-pentest':
        logger.info('Running penetration test...');
        const testType = getOption('type', 'comprehensive');
        const testTarget = getOption('target', 'local');
        const testOptions = getOption('options', '');
        const testPriority = getOption('priority', 'high');
        
        // Start plugin
        const pentestPlugin = await startPlugin();
        
        // Queue pentest task
        const pentestTask = await pentestPlugin.penitentCollection.insertOne({
          taskType: 'pentest',
          testType,
          targetId: testTarget,
          testOptions: testOptions ? JSON.parse(testOptions) : {},
          priority: testPriority,
          status: 'pending',
          createdAt: new Date(),
          scheduledTime: new Date()
        });
        
        logger.info(`Pentest task queued with ID ${pentestTask.insertedId}`);
        
        // Process the task
        await pentestPlugin._processNextPendingTask();
        
        // Keep process alive until task completes
        await waitForTaskCompletion(pentestPlugin, pentestTask.insertedId);
        
        await pentestPlugin.stop();
        process.exit(0);
        break;
        
      case 'get-status':
        logger.info('Getting plugin status...');
        const statusPlugin = await startPlugin();
        const status = statusPlugin.getStatus();
        console.log(JSON.stringify(status, null, 2));
        await statusPlugin.stop();
        process.exit(0);
        break;
        
      case 'help':
      default:
        showHelp();
        process.exit(0);
    }
  } catch (error) {
    logger.error('Error executing command', { error: error.message });
    process.exit(1);
  }
}

// Wait for task completion
async function waitForTaskCompletion(plugin, taskId) {
  return new Promise(resolve => {
    const checkInterval = setInterval(async () => {
      const task = await plugin.penitentCollection.findOne({ _id: taskId });
      
      if (task && (task.status === 'completed' || task.status === 'failed')) {
        clearInterval(checkInterval);
        
        logger.info(`Task ${taskId} ${task.status}`, {
          results: task.results,
          error: task.error
        });
        
        resolve(task);
      }
    }, 2000);
    
    // Set a timeout in case task gets stuck
    setTimeout(() => {
      clearInterval(checkInterval);
      logger.warn(`Task ${taskId} timed out waiting for completion`);
      resolve(null);
    }, 10 * 60 * 1000); // 10 minute timeout
  });
}

// Run the main function
if (require.main === module) {
  main().catch(error => {
    logger.error('Unhandled error', { error: error.message });
    process.exit(1);
  });
}
```


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Security and Pentesting - Monitoring Documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="../css/styles.css">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../index.html">IQSMS Documentation</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Home</a>
                    </li>
                    <li class="nav-item dropdown active">
                        <a class="nav-link dropdown-toggle" href="#" id="monitoringDropdown" role="button" data-toggle="dropdown">
                            Monitoring
                        </a>
                        <div class="dropdown-menu">
                            <a class="dropdown-item" href="index.html">Monitoring Overview</a>
                            <a class="dropdown-item" href="dashboard_guide.html">Dashboard Guide</a>
                            <a class="dropdown-item" href="metrics_collection.html">Metrics Collection</a>
                            <a class="dropdown-item" href="worker_management.html">Worker Management</a>
                            <a class="dropdown-item" href="performance_testing.html">Performance Testing</a>
                            <a class="dropdown-item active" href="pentesting.html">Network Security</a>
                        </div>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../plugins/index.html">Plugins</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../protocols/index.html">Protocols</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="jumbotron jumbotron-fluid bg-primary text-white">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-4">Network Security and Pentesting</h1>
                    <p class="lead">Automated security testing and monitoring for distributed networks</p>
                </div>
                <div class="col-md-4 text-center">
                    <i class="fas fa-shield-alt fa-6x"></i>
                </div>
            </div>
        </div>
    </div>

    <div class="container my-5">
        <div class="row">
            <div class="col-md-3">
                <div class="sticky-top pt-4">
                    <div class="list-group">
                        <a href="#overview" class="list-group-item list-group-item-action">Overview</a>
                        <a href="#features" class="list-group-item list-group-item-action">Key Features</a>
                        <a href="#architecture" class="list-group-item list-group-item-action">Architecture</a>
                        <a href="#configuration" class="list-group-item list-group-item-action">Configuration</a>
                        <a href="#scheduled-testing" class="list-group-item list-group-item-action">Scheduled Testing</a>
                        <a href="#distributed-testing" class="list-group-item list-group-item-action">Distributed Testing</a>
                        <a href="#self-healing" class="list-group-item list-group-item-action">Self-Healing</a>
                        <a href="#metrics" class="list-group-item list-group-item-action">Metrics & Alerts</a>
                        <a href="#troubleshooting" class="list-group-item list-group-item-action">Troubleshooting</a>
                    </div>
                </div>
            </div>
            
            <div class="col-md-9">
                <section id="overview">
                    <h2>Overview</h2>
                    <p>
                        The Network Security and Pentesting module is a comprehensive solution for continuous security monitoring,
                        vulnerability scanning, and automated penetration testing of your distributed network infrastructure. It utilizes
                        industry-standard tools like Snort for intrusion detection and Nmap for vulnerability assessment, packaged in
                        a self-contained plugin that integrates with the monitoring framework.
                    </p>
                    <p>
                        The plugin operates on a scheduled basis, performing various levels of security testing from basic hourly checks
                        to comprehensive monthly penetration tests. It can coordinate testing across multiple cores and automatically
                        remediate detected vulnerabilities through its self-healing capabilities.
                    </p>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i> The plugin is designed to operate within Docker containers to isolate
                        security testing tools from the main system, ensuring a clean and controlled environment for testing.
                    </div>
                </section>

                <section id="features" class="mt-5">
                    <h2>Key Features</h2>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-shield-alt"></i> Intrusion Detection</h5>
                                </div>
                                <div class="card-body">
                                    <p>Real-time monitoring using Snort with regularly updated rules to detect intrusion attempts and suspicious activity.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-search"></i> Vulnerability Scanning</h5>
                                </div>
                                <div class="card-body">
                                    <p>Regular scanning of network infrastructure to identify open ports, misconfigurations, and potential vulnerabilities.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-user-secret"></i> Penetration Testing</h5>
                                </div>
                                <div class="card-body">
                                    <p>Comprehensive security assessment of network infrastructure using various tools and techniques to identify security weaknesses.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-network-wired"></i> Distributed Testing</h5>
                                </div>
                                <div class="card-body">
                                    <p>Coordinate security testing across multiple cores in the distributed network for comprehensive coverage.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-medkit"></i> Self-Healing</h5>
                                </div>
                                <div class="card-body">
                                    <p>Automatically remediate detected vulnerabilities by applying security fixes and configuration changes.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-4">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0"><i class="fas fa-sync"></i> Rule Management</h5>
                                </div>
                                <div class="card-body">
                                    <p>Automatic updates of Snort rules and IP blacklists to stay current with the latest security threats.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="architecture" class="mt-5">
                    <h2>Architecture</h2>
                    <p>
                        The Network Security and Pentesting module consists of several components that work together to provide
                        comprehensive security monitoring and testing capabilities.
                    </p>
                    <div class="text-center mb-4">
                        <img src="../images/pentest-architecture.png" alt="Pentest Architecture Diagram" class="img-fluid border rounded">
                        <p class="text-muted mt-2">Figure 1: Pentest Plugin Architecture</p>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="thead-light">
                                <tr>
                                    <th>Component</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>PentestPlugin</td>
                                    <td>Main class that orchestrates all operations and integrates with the monitoring framework</td>
                                </tr>
                                <tr>
                                    <td>DockerContainerManager</td>
                                    <td>Manages Docker containers for security tools like Snort and Nmap</td>
                                </tr>
                                <tr>
                                    <td>SnortRulesManager</td>
                                    <td>Handles downloading, updating, and managing Snort rules</td>
                                </tr>
                                <tr>
                                    <td>ScannerManager</td>
                                    <td>Coordinates different scanning tools and techniques</td>
                                </tr>
                                <tr>
                                    <td>ReportingSystem</td>
                                    <td>Processes scan results, generates reports, and raises alerts</td>
                                </tr>
                                <tr>
                                    <td>PentestScheduler</td>
                                    <td>Schedules and manages security testing tasks</td>
                                </tr>
                                <tr>
                                    <td>PentestCommunicator</td>
                                    <td>Enables secure communication between cores for distributed testing</td>
                                </tr>
                                <tr>
                                    <td>PentestLogManager</td>
                                    <td>Manages logs, log rotation, and log searching</td>
                                </tr>
                                <tr>
                                    <td>Penitent Collection</td>
                                    <td>MongoDB collection for storing and managing testing tasks</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section id="configuration" class="mt-5">
                    <h2>Configuration</h2>
                    <p>
                        The Network Security and Pentesting module can be configured through the <code>config.json</code> file in the plugin directory.
                    </p>
                    <div class="card mb-4">
                        <div class="card-header bg-light">
                            <h5 class="mb-0">Configuration Example</h5>
                        </div>
                        <div class="card-body">
                            <pre class="bg-light p-3 rounded"><code>{
  "docker": {
    "enabled": true,
    "baseImage": "snort3/snort",
    "containerName": "pentest-snort-container",
    "networkMode": "host",
    "volumes": [
      "./rules:/etc/snort/rules",
      "./logs:/var/log/snort"
    ]
  },
  "rules": {
    "updateInterval": 86400000,
    "snortRulesUrl": "https://www.snort.org/downloads/community/snort3-community-rules.tar.gz",
    "customRulesDir": "./custom-rules"
  },
  "scanners": {
    "nmap": {
      "enabled": true,
      "scheduledScans": {
        "quickScan": {
          "cronSchedule": "0 * * * *",
          "targets": "localnet",
          "options": "-sV -F --open"
        },
        "fullScan": {
          "cronSchedule": "0 0 * * 0",
          "targets": "localnet",
          "options": "-sV -O -A"
        }
      }
    },
    "snort": {
      "enabled": true,
      "configFile": "/etc/snort/snort.conf",
      "interfaces": ["eth0"]
    }
  },
  "reporting": {
    "alertThreshold": "medium",
    "reportInterval": 3600000,
    "detailedReporting": true,
    "dashboardIntegration": true
  },
  "scheduler": {
    "defaultScanInterval": 3600000,
    "pentestSchedule": "0 0 * * 1",
    "pressureTestSchedule": "0 0 1 * *"
  },
  "communication": {
    "encryptionEnabled": true,
    "authRequired": true,
    "requestTimeout": 30000
  },
  "logging": {
    "level": "info",
    "retentionDays": 30,
    "maxLogSize": 52428800
  }
}</code></pre>
                        </div>
                    </div>
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i> When deploying in production, ensure that the network configuration 
                        is properly set to restrict access to the Docker container and its network interfaces.
                    </div>
                </section>

                <section id="scheduled-testing" class="mt-5">
                    <h2>Scheduled Testing</h2>
                    <p>
                        The plugin supports scheduled security testing using cron-like expressions. Different types of tests can be scheduled
                        at different intervals based on your security requirements.
                    </p>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="thead-light">
                                <tr>
                                    <th>Test Type</th>
                                    <th>Default Schedule</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Quick Port Scan</td>
                                    <td>Hourly (<code>0 * * * *</code>)</td>
                                    <td>Basic port scan to identify newly opened services</td>
                                </tr>
                                <tr>
                                    <td>Full Network Scan</td>
                                    <td>Weekly on Sunday (<code>0 0 * * 0</code>)</td>
                                    <td>Comprehensive scan with service detection and OS fingerprinting</td>
                                </tr>
                                <tr>
                                    <td>Comprehensive Pentest</td>
                                    <td>Weekly on Monday (<code>0 0 * * 1</code>)</td>
                                    <td>Full penetration test with vulnerability assessment</td>
                                </tr>
                                <tr>
                                    <td>Pressure Test</td>
                                    <td>Monthly on the 1st (<code>0 0 1 * *</code>)</td>
                                    <td>High-intensity testing to assess system resilience</td>
                                </tr>
                                <tr>
                                    <td>Rule Updates</td>
                                    <td>Daily (24-hour interval)</td>
                                    <td>Update Snort rules and IP blacklists</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>
                        You can customize these schedules in the configuration file to match your organization's security policies and operational requirements.
                    </p>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i> Cron expressions follow the standard format: <code>minute hour day-of-month month day-of-week</code>.
                        For example, <code>0 * * * *</code> means "at minute 0 of every hour".
                    </div>
                </section>

                <section id="distributed-testing" class="mt-5">
                    <h2>Distributed Testing</h2>
                    <p>
                        The plugin supports distributed security testing across multiple cores in your network. This allows for comprehensive
                        coverage of the entire infrastructure and can identify vulnerabilities that might only be visible from certain
                        network segments.
                    </p>
                    <div class="card mb-4">
                        <div class="card-header bg-light">
                            <h5 class="mb-0">Distributed Testing Process</h5>
                        </div>
                        <div class="card-body">
                            <ol>
                                <li>The initiating core sends a pentest request to other cores</li>
                                <li>Each core performs local security testing based on the request parameters</li>
                                <li>Test results and discovered vulnerabilities are reported back to the initiating core</li>
                                <li>The initiating core aggregates and processes the results</li>
                                <li>Critical vulnerabilities trigger self-healing actions on the affected cores</li>
                            </ol>
                        </div>
                    </div>
                    <p>
                        Communication between cores is secured using encryption and authentication to prevent unauthorized access to
                        sensitive security information.
                    </p>
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i> Distributed testing requires proper configuration of the communication
                        settings on all participating cores. Ensure that cores can communicate securely with each other.
                    </div>
                </section>

                <section id="self-healing" class="mt-5">
                    <h2>Self-Healing Capabilities</h2>
                    <p>
                        The plugin includes self-healing capabilities that can automatically remediate certain types of vulnerabilities.
                        This reduces the need for manual intervention and shortens the window of exposure to potential threats.
                    </p>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="thead-light">
                                <tr>
                                    <th>Vulnerability Type</th>
                                    <th>Remediation Strategy</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Open Ports</td>
                                    <td>Configure firewall rules to restrict access to unauthorized ports</td>
                                </tr>
                                <tr>
                                    <td>Malicious IP Activity</td>
                                    <td>Block IPs associated with malicious activity</td>
                                </tr>
                                <tr>
                                    <td>Vulnerable Services</td>
                                    <td>Apply patches or configuration changes to vulnerable services</td>
                                </tr>
                                <tr>
                                    <td>Weak Configurations</td>
                                    <td>Apply security hardening to weak configurations</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>
                        Self-healing actions are queued in the Penitent collection and executed based on priority. Critical vulnerabilities
                        are remediated first, followed by high, medium, and low severity issues.
                    </p>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i> Self-healing is enabled by default but can be disabled in the configuration
                        if you prefer to review and manually approve remediation actions.
                    </div>
                </section>

                <section id="metrics" class="mt-5">
                    <h2>Metrics & Alerts</h2>
                    <p>
                        The plugin integrates with the monitoring framework to provide metrics and alerts related to security testing
                        and vulnerability detection.
                    </p>
                    <h4>Metrics</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="thead-light">
                                <tr>
                                    <th>Metric Name</th>
                                    <th>Type</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>pentest_plugin_status</td>
                                    <td>Gauge</td>
                                    <td>Current status of the pentest plugin</td>
                                </tr>
                                <tr>
                                    <td>pentest_scans_total</td>
                                    <td>Counter</td>
                                    <td>Total number of security scans performed</td>
                                </tr>
                                <tr>
                                    <td>pentest_vulnerabilities_detected</td>
                                    <td>Counter</td>
                                    <td>Number of vulnerabilities detected</td>
                                </tr>
                                <tr>
                                    <td>pentest_rule_updates</td>
                                    <td>Counter</td>
                                    <td>Number of rule updates performed</td>
                                </tr>
                                <tr>
                                    <td>pentest_self_healing</td>
                                    <td>Counter</td>
                                    <td>Number of self-healing actions performed</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <h4 class="mt-4">Alerts</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="thead-light">
                                <tr>
                                    <th>Alert Name</th>
                                    <th>Severity</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>high_severity_vulnerability</td>
                                    <td>Critical</td>
                                    <td>A high severity vulnerability was detected</td>
                                </tr>
                                <tr>
                                    <td>scan_failure</td>
                                    <td>Warning</td>
                                    <td>A security scan failed to complete</td>
                                </tr>
                                <tr>
                                    <td>pentest_failure</td>
                                    <td>Warning</td>
                                    <td>A penetration test failed to complete</td>
                                </tr>
                                <tr>
                                    <td>self_healing_failure</td>
                                    <td>Warning</td>
                                    <td>A self-healing action failed to complete</td>
                                </tr>
                                <tr>
                                    <td>rule_update_failure</td>
                                    <td>Warning</td>
                                    <td>A rule update failed to complete</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="alert alert-info mt-3">
                        <i class="fas fa-info-circle"></i> These metrics and alerts are displayed in the monitoring dashboard and can be used to
                        create custom visualizations and alert rules.
                    </div>
                </section>

                <section id="troubleshooting" class="mt-5">
                    <h2>Troubleshooting</h2>
                    <p>
                        Common issues and their solutions:
                    </p>
                    <div class="accordion" id="troubleshootingAccordion">
                        <div class="card">
                            <div class="card-header" id="headingOne">
                                <h2 class="mb-0">
                                    <button class="btn btn-link btn-block text-left" type="button" data-toggle="collapse" data-target="#collapseOne">
                                        Docker container fails to start
                                    </button>
                                </h2>
                            </div>
                            <div id="collapseOne" class="collapse" data-parent="#troubleshootingAccordion">
                                <div class="card-body">
                                    <p><strong>Possible causes:</strong></p>
                                    <ul>
                                        <li>Docker service is not running</li>
                                        <li>Insufficient permissions</li>
                                        <li>Port conflicts</li>
                                    </ul>
                                    <p><strong>Solutions:</strong></p>
                                    <ol>
                                        <li>Check Docker service status: <code>systemctl status docker</code></li>
                                        <li>Ensure the user has Docker permissions</li>
                                        <li>Check for port conflicts: <code>netstat -tulpn | grep LISTEN</code></li>
                                        <li>Review Docker container logs: <code>docker logs pentest-snort-container</code></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header" id="headingTwo">
                                <h2 class="mb-0">
                                    <button class="btn btn-link btn-block text-left collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo">
                                        Rule updates failing
                                    </button>
                                </h2>
                            </div>
                            <div id="collapseTwo" class="collapse" data-parent="#troubleshootingAccordion">
                                <div class="card-body">
                                    <p><strong>Possible causes:</strong></p>
                                    <ul>
                                        <li>Network connectivity issues</li>
                                        <li>URL changes for rule sources</li>
                                        <li>Permission issues for rule directories</li>
                                    </ul>
                                    <p><strong>Solutions:</strong></p>
                                    <ol>
                                        <li>Check network connectivity to rule sources</li>
                                        <li>Verify rule URLs in configuration</li>
                                        <li>Check directory permissions</li>
                                        <li>Review rule update logs: <code>private/plugins/modules/pentest/logs/system/rule-updates.log</code></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header" id="headingThree">
                                <h2 class="mb-0">
                                    <button class="btn btn-link btn-block text-left collapsed" type="button" data-toggle="collapse" data-target="#collapseThree">
                                        Distributed testing not working
                                    </button>
                                </h2>
                            </div>
                            <div id="collapseThree" class="collapse" data-parent="#troubleshootingAccordion">
                                <div class="card-body">
                                    <p><strong>Possible causes:</strong></p>
                                    <ul>
                                        <li>Communication issues between cores</li>
                                        <li>Authentication or encryption configuration mismatches</li>
                                        <li>Message bus connectivity issues</li>
                                    </ul>
                                    <p><strong>Solutions:</strong></p>
                                    <ol>
                                        <li>Verify network connectivity between cores</li>
                                        <li>Check encryption and authentication settings</li>
                                        <li>Ensure message bus is running and accessible</li>
                                        <li>Review communication logs: <code>private/plugins/modules/pentest/logs/system/communication.log</code></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header" id="headingFour">
                                <h2 class="mb-0">
                                    <button class="btn btn-link btn-block text-left collapsed" type="button" data-toggle="collapse" data-target="#collapseFour">
                                        Self-healing actions failing
                                    </button>
                                </h2>
                            </div>
                            <div id="collapseFour" class="collapse" data-parent="#troubleshootingAccordion">
                                <div class="card-body">
                                    <p><strong>Possible causes:</strong></p>
                                    <ul>
                                        <li>Insufficient permissions for remediation actions</li>
                                        <li>Changes in system configuration</li>
                                        <li>Conflicts with other security systems</li>
                                    </ul>
                                    <p><strong>Solutions:</strong></p>
                                    <ol>
                                        <li>Check permissions for remediation actions</li>
                                        <li>Review system configuration</li>
                                        <li>Check for conflicts with other security systems</li>
                                        <li>Review self-healing logs: <code>private/plugins/modules/pentest/logs/system/self-healing.log</code></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="alert alert-info mt-3">
                        <i class="fas fa-info-circle"></i> For additional troubleshooting assistance, check the logs in the
                        <code>private/plugins/modules/pentest/logs</code> directory or contact the security team.
                    </div>
                </section>
            </div>
        </div>
    </div>

    <footer class="bg-dark text-white py-4">
        <div class="container">
            <div class="row">
                <div class="col-md-6">
                    <h5>IQSMS Documentation</h5>
                    <p>Comprehensive documentation for the IQSMS platform.</p>
                </div>
                <div class="col-md-3">
                    <h5>Links</h5>
                    <ul class="list-unstyled">
                        <li><a href="../index.html" class="text-white">Home</a></li>
                        <li><a href="index.html" class="text-white">Monitoring</a></li>
                        <li><a href="../plugins/index.html" class="text-white">Plugins</a></li>
                    </ul>
                </div>
                <div class="col-md-3">
                    <h5>Legal</h5>
                    <p class="small">Copyright 2025 Autonomy Association International Inc., all rights reserved</p>
                    <p class="small">Safeguard patent license from National Aeronautics and Space Administration (NASA)</p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
```


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IQSMS Documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html">IQSMS Documentation</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="monitoringDropdown" role="button" data-toggle="dropdown">
                            Monitoring
                        </a>
                        <div class="dropdown-menu">
                            <a class="dropdown-item" href="monitoring/index.html">Monitoring Overview</a>
                            <a class="dropdown-item" href="monitoring/dashboard_guide.html">Dashboard Guide</a>
                            <a class="dropdown-item" href="monitoring/metrics_collection.html">Metrics Collection</a>
                            <a class="dropdown-item" href="monitoring/worker_management.html">Worker Management</a>
                            <a class="dropdown-item" href="monitoring/performance_testing.html">Performance Testing</a>
                            <a class="dropdown-item" href="monitoring/pentesting.html">Network Security</a>
                        </div>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="plugins/index.html">Plugins</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="protocols/index.html">Protocols</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="jumbotron jumbotron-fluid bg-primary text-white">
        <div class="container">
            <h1 class="display-4">IQSMS Documentation</h1>
            <p class="lead">Comprehensive documentation for the IQ Safety Management Surveillance System</p>
        </div>
    </div>

    <div class="container my-5">
        <div class="row">
            <div class="col-md-4 mb-4">
                <div class="card h-100">
                    <div class="card-header bg-primary text-white">
                        <h3><i class="fas fa-tachometer-alt"></i> Monitoring</h3>
                    </div>
                    <div class="card-body">
                        <p>Documentation for the monitoring system, including dashboards, metrics collection, and performance testing.</p>
                        <ul class="list-unstyled">
                            <li><a href="monitoring/index.html">Monitoring Overview</a></li>
                            <li><a href="monitoring/dashboard_guide.html">Dashboard Guide</a></li>
                            <li><a href="monitoring/metrics_collection.html">Metrics Collection</a></li>
                            <li><a href="monitoring/worker_management.html">Worker Management</a></li>
                            <li><a href="monitoring/performance_testing.html">Performance Testing</a></li>
                            <li><a href="monitoring/pentesting.html">Network Security</a></li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <a href="monitoring/index.html" class="btn btn-primary">Explore Monitoring</a>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4 mb-4">
                <div class="card h-100">
                    <div class="card-header bg-success text-white">
                        <h3><i class="fas fa-puzzle-piece"></i> Plugins</h3>
                    </div>
                    <div class="card-body">
                        <p>Documentation for the plugin system, including development guides and available plugins.</p>
                        <ul class="list-unstyled">
                            <li><a href="plugins/index.html">Plugins Overview</a></li>
                            <li><a href="plugins/development.html">Plugin Development</a></li>
                            <li><a href="plugins/load-balancer.html">Load Balancer Plugin</a></li>
                            <li><a href="plugins/security-manager.html">Security Manager Plugin</a></li>
                            <li><a href="plugins/oci-container-manager.html">OCI Container Manager</a></li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <a href="plugins/index.html" class="btn btn-success">Explore Plugins</a>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4 mb-4">
                <div class="card h-100">
                    <div class="card-header bg-info text-white">
                        <h3><i class="fas fa-exchange-alt"></i> Protocols</h3>
                    </div>
                    <div class="card-body">
                        <p>Documentation for communication protocols used in the IQSMS system.</p>
                        <ul class="list-unstyled">
                            <li><a href="protocols/index.html">Protocols Overview</a></li>
                            <li><a href="protocols/agent-protocol.html">Agent Protocol</a></li>
                            <li><a href="protocols/mcp.html">Model Context Protocol</a></li>
                            <li><a href="protocols/json-rpc.html">JSON-RPC Protocol</a></li>
                            <li><a href="protocols/agent_to_agent_communication_protocol.html">Agent-to-Agent Protocol</a></li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <a href="protocols/index.html" class="btn btn-info">Explore Protocols</a>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-4">
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header bg-warning text-dark">
                        <h3><i class="fas fa-shield-alt"></i> Security</h3>
                    </div>
                    <div class="card-body">
                        <p>Documentation for security features and best practices in the IQSMS system.</p>
                        <ul class="list-unstyled">
                            <li><a href="security/index.html">Security Overview</a></li>
                            <li><a href="security/authentication.html">Authentication</a></li>
                            <li><a href="security/authorization.html">Authorization</a></li>
                            <li><a href="monitoring/pentesting.html">Network Security and Pentesting</a></li>
                            <li><a href="security/encryption.html">Encryption</a></li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <a href="security/index.html" class="btn btn-warning">Explore Security</a>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header bg-danger text-white">
                        <h3><i class="fas fa-cogs"></i> Services</h3>
                    </div>
                    <div class="card-body">
                        <p>Documentation for core services provided by the IQSMS system.</p>
                        <ul class="list-unstyled">
                            <li><a href="services/index.html">Services Overview</a></li>
                            <li><a href="services/trajectory.html">Trajectory Planning</a></li>
                            <li><a href="services/geofencing.html">Geofencing</a></li>
                            <li><a href="services/vehicle-management.html">Vehicle Management</a></li>
                            <li><a href="services/beacons.html">Beacon Management</a></li>
                        </ul>
                    </div>
                    <div class="card-footer">
                        <a href="services/index.html" class="btn btn-danger">Explore Services</a>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-4">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-header bg-dark text-white">
                        <h3><i class="fas fa-book"></i> Getting Started</h3>
                    </div>
                    <div class="card-body">
                        <p>New to the IQSMS system? Start here to learn the basics and get up and running quickly.</p>
                        <div class="row">
                            <div class="col-md-6">
                                <h4>Installation & Setup</h4>
                                <ul>
                                    <li><a href="getting-started.html">Installation Guide</a></li>
                                    <li><a href="system_info.html">System Requirements</a></li>
                                    <li><a href="troubleshooting.html">Troubleshooting</a></li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h4>Core Concepts</h4>
                                <ul>
                                    <li><a href="core/architecture.html">System Architecture</a></li>
                                    <li><a href="core/components.html">Key Components</a></li>
                                    <li><a href="examples.html">Examples & Tutorials</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer">
                        <a href="getting-started.html" class="btn btn-dark">Get Started</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-dark text-white py-4">
        <div class="container">
            <div class="row">
                <div class="col-md-6">
                    <h5>IQSMS Documentation</h5>
                    <p>Comprehensive documentation for the IQSMS platform.</p>
                </div>
                <div class="col-md-3">
                    <h5>Links</h5>
                    <ul class="list-unstyled">
                        <li><a href="index.html" class="text-white">Home</a></li>
                        <li><a href="monitoring/index.html" class="text-white">Monitoring</a></li>
                        <li><a href="plugins/index.html" class="text-white">Plugins</a></li>
                    </ul>
                </div>
                <div class="col-md-3">
                    <h5>Legal</h5>
                    <p class="small">Copyright 2025 Autonomy Association International Inc., all rights reserved</p>
                    <p class="small">Safeguard patent license from National Aeronautics and Space Administration (NASA)</p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
```


## Network Security Pentesting Plugin Implementation Summary

I've developed a comprehensive Network Security and Penetration Testing plugin for your system. This plugin addresses all the requirements specified and provides a robust solution for security monitoring, testing, and self-healing in your distributed network environment.

### Key Features Implemented

1. **Docker-Based Security Tools**: Developed a Docker container with Snort, Nmap, and other security tools for isolated testing.

2. **Automated Rule Management**: Created a system that automatically updates Snort rules and IP blacklists to stay current with the latest threats.

3. **Scheduled Testing**: Implemented a flexible scheduler for various security testing levels:
    - Hourly port scans
    - Daily log checks
    - Weekly full network scans
    - Monthly comprehensive penetration tests

4. **Distributed Testing**: Built a secure communication protocol for coordinating security testing across multiple cores.

5. **Self-Healing Capabilities**: Implemented automated remediation for common vulnerabilities:
    - Port restriction for unauthorized open ports
    - IP blocking for malicious activity
    - Service patching for vulnerable applications

6. **Monitoring Integration**: Integrated with the monitoring framework to provide metrics and alerts.

7. **Type-Safe Task Queue**: Used the Zod schema for the Penitent collection to ensure type safety for queued tasks.

### Components Created

1. **PentestPlugin**: The main class that orchestrates all security testing operations.
2. **DockerContainerManager**: Handles Docker container lifecycle for security tools.
3. **SnortRulesManager**: Manages downloading, updating, and deploying Snort rules.
4. **ScannerManager**: Coordinates different scanning tools and techniques.
5. **ReportingSystem**: Processes results and generates vulnerability reports.
6. **PentestScheduler**: Schedules and manages security testing tasks.
7. **PentestCommunicator**: Enables secure communication between cores.
8. **PentestLogManager**: Manages logs, rotation, and searching.
9. **PenitentModel**: Zod schema model for the task queue.

### Documentation

I've created comprehensive documentation in the `/docs/monitoring/pentesting.html` page, which explains:
- The plugin architecture and components
- Configuration options and customization
- Scheduled testing capabilities
- Distributed testing approach
- Self-healing mechanisms
- Integration with the monitoring framework
- Troubleshooting guidance

I've also updated the main `/docs/index.html` to include navigation to the new Network Security section.

### Implementation Approach

The implementation follows best practices for security testing:

1. **Isolation**: Security tools run in Docker containers to prevent impact on production systems.
2. **Automation**: Scheduled tasks run with minimal human intervention.
3. **Scalability**: The architecture supports distributed testing across many cores.
4. **Flexibility**: Configuration options allow customization for different environments.
5. **Modularity**: Components can be extended or replaced as needed.

### Next Steps

To deploy this solution:

1. Ensure Docker is installed on all systems where security testing will run.
2. Configure the plugin with appropriate network settings for your environment.
3. Customize the scanning schedules to match your security policies.
4. Deploy the plugin to your cores and initialize it.
5. Monitor the results through the integrated monitoring dashboard.

This implementation provides a robust foundation for ongoing security testing and monitoring in your distributed network environment, with the ability to automatically detect and remediate vulnerabilities.

I'll build a list of proper names and paths from the pentest module code based on your request.

## Pentest Module Names and Paths

### Main Scripts and Classes
- `PentestPlugin.js` - `/private/plugin/modules/pentest/PentestPlugin.js`
- `PentestPluginManager.js` - `/private/plugin/modules/pentest/PentestPluginManager.js`
- `DockerContainerManager.js` - `/private/plugin/modules/pentest/DockerContainerManager.js`
- `PentestLogManager.js` - `/private/plugin/modules/pentest/PentestLogManager.js`
- `PentestPluginCLI.js` - `/private/plugin/modules/pentest/PentestPluginCLI.js`
- `PentestScheduler.js` - `/private/plugin/modules/pentest/PentestScheduler.js`
- `PentestCommunicator.js` - `/private/plugin/modules/pentest/PentestCommunicator.js`
- `PenitentTaskManager.js` - `/private/plugin/modules/pentest/PenitentTaskManager.js`
- `ReportingSystem.js` - `/private/plugin/modules/pentest/ReportingSystem.js`
- `ScannerManager.js` - `/private/plugin/modules/pentest/ScannerManager.js`

### Snort-Related Components
- `SnortRulesManager.js` - `/private/plugin/modules/pentest/SnortRulesManager.js`
- `RulesUpdater.js` - `/private/plugin/modules/pentest/RulesUpdater.js`
- `SnortRulesUpdater.sh` - `/private/plugin/modules/pentest/SnortRulesUpdater.sh`
- `SnortRulesIQSMSPlugin.rules` - `/private/plugin/modules/pentest/SnortRulesIQSMSPlugin.rules`
- `Snort3Configuration.yaml` - `/private/plugin/modules/pentest/Snort3Configuration.yaml`

### Entry Points and Configuration
- `PentestPluginEntryPoint.sh` - `/private/plugin/modules/pentest/PentestPluginEntryPoint.sh`
- `config.json` - `/private/plugin/modules/pentest/config.json`
- `Dockerfile` - `/private/plugin/modules/pentest/Dockerfile`

### Documentation Files
- `PentestPluginArchitecture.md` - `/private/plugin/modules/pentest/PentestPluginArchitecture.md`
- `PentestPluginNetworkSecurity.md` - `/private/plugin/modules/pentest/PentestPluginNetworkSecurity.md`
- `_pentestLLM.md` - `/private/plugin/modules/pentest/_pentestLLM.md`

### Web Interface and Documentation
- Network security pentesting documentation HTML at `/docs/monitoring/pentesting.html`
- Main documentation index at `/docs/index.html`

### Support Files
- Network security icons in `/docs/images/pentesting/` directory:
    - `network-security.svg`
    - `security-assessment-process.svg`
    - `vulnerability-scan.svg`

This list represents the key files and their paths in the pentest module, organized by functional categories.